"use strict";(self.webpackChunkzkbnb_docs=self.webpackChunkzkbnb_docs||[]).push([[5941],{3905:(t,e,n)=>{n.d(e,{Zo:()=>d,kt:()=>k});var a=n(67294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function l(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?l(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},l=Object.keys(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var u=a.createContext({}),s=function(t){var e=a.useContext(u),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},d=function(t){var e=s(t.components);return a.createElement(u.Provider,{value:e},t.children)},c="mdxType",p={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},f=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,l=t.originalType,u=t.parentName,d=o(t,["components","mdxType","originalType","parentName"]),c=s(n),f=r,k=c["".concat(u,".").concat(f)]||c[f]||p[f]||l;return n?a.createElement(k,i(i({ref:e},d),{},{components:n})):a.createElement(k,i({ref:e},d))}));function k(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=n.length,i=new Array(l);i[0]=f;var o={};for(var u in e)hasOwnProperty.call(e,u)&&(o[u]=e[u]);o.originalType=t,o[c]="string"==typeof t?t:r,i[1]=o;for(var s=2;s<l;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},92335:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>u,contentTitle:()=>i,default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>s});var a=n(87462),r=(n(67294),n(3905));const l={title:"zkBNB Protocol"},i="zkBNB Protocol Design",o={unversionedId:"guide/core-concepts/protocol",id:"guide/core-concepts/protocol",title:"zkBNB Protocol",description:"Glossary",source:"@site/docs/guide/core-concepts/protocol.md",sourceDirName:"guide/core-concepts",slug:"/guide/core-concepts/protocol",permalink:"/zkBNB-docs/docs/guide/core-concepts/protocol",draft:!1,editUrl:"https://github.com/RumeelHussainbnb/zkBNB-docs/docs/guide/core-concepts/protocol.md",tags:[],version:"current",frontMatter:{title:"zkBNB Protocol"},sidebar:"guideSidebar",previous:{title:"zkBNB Architecture",permalink:"/zkBNB-docs/docs/guide/core-concepts/zkbnb-arch"},next:{title:"Storage Layout",permalink:"/zkBNB-docs/docs/guide/storage/storage-layout"}},u={},s=[{value:"Glossary",id:"glossary",level:2},{value:"Design",id:"design",level:2},{value:"Overview",id:"overview",level:3},{value:"Data format",id:"data-format",level:2},{value:"Data types",id:"data-types",level:3},{value:"Amount packing",id:"amount-packing",level:3},{value:"State Merkle Tree(height)",id:"state-merkle-treeheight",level:3},{value:"AccountTree",id:"accounttree",level:4},{value:"AssetTree",id:"assettree",level:5},{value:"NftTree",id:"nfttree",level:4},{value:"StateRoot",id:"stateroot",level:4},{value:"zkBNB Transactions",id:"zkbnb-transactions",level:2},{value:"Rollup transaction lifecycle",id:"rollup-transaction-lifecycle",level:3},{value:"EmptyTx",id:"emptytx",level:3},{value:"Description",id:"description",level:4},{value:"On-Chain operation",id:"on-chain-operation",level:4},{value:"Size",id:"size",level:5},{value:"Structure",id:"structure",level:5},{value:"User transaction",id:"user-transaction",level:4},{value:"RegisterZNS",id:"registerzns",level:3},{value:"Description",id:"description-1",level:4},{value:"On-Chain operation",id:"on-chain-operation-1",level:4},{value:"Size",id:"size-1",level:5},{value:"Structure",id:"structure-1",level:5},{value:"User transaction",id:"user-transaction-1",level:4},{value:"Circuit",id:"circuit",level:4},{value:"Deposit",id:"deposit",level:3},{value:"Description",id:"description-2",level:4},{value:"On-Chain operation",id:"on-chain-operation-2",level:4},{value:"Size",id:"size-2",level:5},{value:"Structure",id:"structure-2",level:5},{value:"User transaction",id:"user-transaction-2",level:4},{value:"DepositBNB",id:"depositbnb",level:5},{value:"DepositBEP20",id:"depositbep20",level:5},{value:"Circuit",id:"circuit-1",level:4},{value:"DepositNft",id:"depositnft",level:3},{value:"Description",id:"description-3",level:4},{value:"On-Chain operation",id:"on-chain-operation-3",level:4},{value:"Size",id:"size-3",level:5},{value:"Structure",id:"structure-3",level:5},{value:"User transaction",id:"user-transaction-3",level:4},{value:"Circuit",id:"circuit-2",level:4},{value:"Transfer",id:"transfer",level:3},{value:"Description",id:"description-4",level:4},{value:"On-Chain operation",id:"on-chain-operation-4",level:4},{value:"Size",id:"size-4",level:5},{value:"Structure",id:"structure-4",level:5},{value:"User transaction",id:"user-transaction-4",level:4},{value:"Circuit",id:"circuit-3",level:4},{value:"Withdraw",id:"withdraw",level:3},{value:"Description",id:"description-5",level:4},{value:"On-Chain operation",id:"on-chain-operation-5",level:4},{value:"Size",id:"size-5",level:5},{value:"Structure",id:"structure-5",level:5},{value:"User transaction",id:"user-transaction-5",level:4},{value:"Circuit",id:"circuit-4",level:4},{value:"CreateCollection",id:"createcollection",level:3},{value:"Description",id:"description-6",level:4},{value:"On-Chain operation",id:"on-chain-operation-6",level:4},{value:"Size",id:"size-6",level:5},{value:"Structure",id:"structure-6",level:5},{value:"User transaction",id:"user-transaction-6",level:4},{value:"Circuit",id:"circuit-5",level:4},{value:"MintNft",id:"mintnft",level:3},{value:"Description",id:"description-7",level:4},{value:"On-Chain operation",id:"on-chain-operation-7",level:4},{value:"Size",id:"size-7",level:5},{value:"Structure",id:"structure-7",level:5},{value:"User transaction",id:"user-transaction-7",level:4},{value:"Circuit",id:"circuit-6",level:4},{value:"TransferNft",id:"transfernft",level:3},{value:"Description",id:"description-8",level:4},{value:"On-Chain operation",id:"on-chain-operation-8",level:4},{value:"Size",id:"size-8",level:5},{value:"Structure",id:"structure-8",level:5},{value:"User transaction",id:"user-transaction-8",level:4},{value:"Circuit",id:"circuit-7",level:4},{value:"AtomicMatch",id:"atomicmatch",level:3},{value:"Description",id:"description-9",level:4},{value:"On-Chain operation",id:"on-chain-operation-9",level:4},{value:"Size",id:"size-9",level:5},{value:"Structure",id:"structure-9",level:5},{value:"User transaction",id:"user-transaction-9",level:4},{value:"Circuit",id:"circuit-8",level:4},{value:"CancelOffer",id:"canceloffer",level:3},{value:"Description",id:"description-10",level:4},{value:"On-Chain operation",id:"on-chain-operation-10",level:4},{value:"Size",id:"size-10",level:5},{value:"Structure",id:"structure-10",level:5},{value:"User transaction",id:"user-transaction-10",level:4},{value:"Circuit",id:"circuit-9",level:4},{value:"WithdrawNft",id:"withdrawnft",level:3},{value:"Description",id:"description-11",level:4},{value:"On-Chain operation",id:"on-chain-operation-11",level:4},{value:"Size",id:"size-11",level:5},{value:"Structure",id:"structure-11",level:5},{value:"User transaction",id:"user-transaction-11",level:4},{value:"Circuit",id:"circuit-10",level:4},{value:"FullExit",id:"fullexit",level:3},{value:"Description",id:"description-12",level:4},{value:"On-Chain operation",id:"on-chain-operation-12",level:4},{value:"Size",id:"size-12",level:5},{value:"Structure",id:"structure-12",level:5},{value:"User transaction",id:"user-transaction-12",level:4},{value:"Circuit",id:"circuit-11",level:4},{value:"FullExitNft",id:"fullexitnft",level:3},{value:"Description",id:"description-13",level:4},{value:"On-Chain operation",id:"on-chain-operation-13",level:4},{value:"Size",id:"size-13",level:5},{value:"Structure",id:"structure-13",level:5},{value:"User transaction",id:"user-transaction-13",level:4},{value:"Circuit",id:"circuit-12",level:4},{value:"Smart contracts API",id:"smart-contracts-api",level:2},{value:"Rollup contract",id:"rollup-contract",level:3},{value:"RegisterZNS",id:"registerzns-1",level:4},{value:"Deposit BNB",id:"deposit-bnb",level:4},{value:"Deposit BEP20",id:"deposit-bep20",level:4},{value:"Withdraw Pending BNB/BEP20",id:"withdraw-pending-bnbbep20",level:4},{value:"Withdraw Pending Nft",id:"withdraw-pending-nft",level:4},{value:"Censorship resistance",id:"censorship-resistance",level:4},{value:"Desert mode",id:"desert-mode",level:4},{value:"Withdraw funds",id:"withdraw-funds",level:5},{value:"Rollup Operations",id:"rollup-operations",level:4},{value:"Commit block",id:"commit-block",level:5},{value:"Verify and execute blocks",id:"verify-and-execute-blocks",level:5},{value:"Desert mode trigger",id:"desert-mode-trigger",level:4},{value:"Revert blocks",id:"revert-blocks",level:4},{value:"Set default NFT factory",id:"set-default-nft-factory",level:4},{value:"Register NFT factory",id:"register-nft-factory",level:4},{value:"Get NFT factory for creator",id:"get-nft-factory-for-creator",level:4},{value:"Governance contract",id:"governance-contract",level:3},{value:"Change governor",id:"change-governor",level:4},{value:"Add asset",id:"add-asset",level:4},{value:"Set asset paused",id:"set-asset-paused",level:4},{value:"Set validator",id:"set-validator",level:4},{value:"Change asset governance",id:"change-asset-governance",level:5},{value:"Check for governor",id:"check-for-governor",level:4},{value:"Check for active validator",id:"check-for-active-validator",level:4},{value:"Check that asset address is valid",id:"check-that-asset-address-is-valid",level:4},{value:"Asset Governance contract",id:"asset-governance-contract",level:3},{value:"Add asset",id:"add-asset-1",level:4},{value:"Set listing fee asset",id:"set-listing-fee-asset",level:4},{value:"Set listing fee",id:"set-listing-fee",level:4},{value:"Set lister",id:"set-lister",level:4},{value:"Set listing cap",id:"set-listing-cap",level:4},{value:"Set treasury",id:"set-treasury",level:4}],d={toc:s};function c(t){let{components:e,...n}=t;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"zkbnb-protocol-design"},"zkBNB Protocol Design"),(0,r.kt)("h2",{id:"glossary"},"Glossary"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"L1"),": layer 1 blockchain, it is BNB Smart Chain."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Rollup"),": Zk Rollup based layer-2 network, it is zkBNB."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Owner"),": A user get a L2 account."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Committer"),": Entity executing transactions and producing consecutive blocks on L2."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Eventually"),": happening within finite time."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Assets in L2"),": Assets in L2 smart contract controlled by owners."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"L2 Key"),": Owner's private key used to send transaction on L2."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"MiMC Signature"),": The result of signing the owner's message,\nusing his private key, used in L2 internal transactions.")),(0,r.kt)("p",null,"The current implementation we still use EDDSA as the signature scheme, we will soon support\nswitch to EDCSA."),(0,r.kt)("h2",{id:"design"},"Design"),(0,r.kt)("h3",{id:"overview"},"Overview"),(0,r.kt)("p",null,'zkBNB implements a zk-rollup protocol (in short "rollup" below) for:'),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"BNB and BEP20 fungible token deposit and transfer"),(0,r.kt)("li",{parentName:"ul"},"BEP721 non-fungible token deposit and transfer"),(0,r.kt)("li",{parentName:"ul"},"mint BEP721 non-fungible tokens on L2"),(0,r.kt)("li",{parentName:"ul"},"NFT-marketplace on L2")),(0,r.kt)("p",null,"General rollup workflow is as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Users can become owners in rollup by calling registerZNS in L1 to register a short name for L2;"),(0,r.kt)("li",{parentName:"ul"},"Owners can transfer assets to each other, mint NFT on L2;"),(0,r.kt)("li",{parentName:"ul"},"Owners can withdraw assets under their control to any L1 address.")),(0,r.kt)("p",null,"Rollup operation requires the assistance of a committer, who rolls transactions together, also a prover who computes\na zero-knowledge proof of the correct state transition, and affects the state transition by interacting with the\nrollup contract."),(0,r.kt)("h2",{id:"data-format"},"Data format"),(0,r.kt)("h3",{id:"data-types"},"Data types"),(0,r.kt)("p",null,"We assume that 1 ",(0,r.kt)("inlineCode",{parentName:"p"},"Chunk")," = 32 bytes."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(Byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"uint32"),(0,r.kt)("td",{parentName:"tr",align:null},"Incremented number of accounts in Rollup. New account will have the next free id. Max value is 2^32 - 1 = 4.294967295 \xd7 10^9")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AssetId"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"uint16"),(0,r.kt)("td",{parentName:"tr",align:null},"Incremented number of tokens in Rollup, max value is 65535")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PackedTxAmount"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"Packed transactions amounts are represented with 40 bit (5 byte) values, encoded as mantissa \xd7 10^exponent where mantissa is represented with 35 bits, exponent is represented with 5 bits. This gives a range from 0 to 34359738368 \xd7 10^31, providing 10 full decimal digit precision.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PackedFee"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"uint16"),(0,r.kt)("td",{parentName:"tr",align:null},"Packed fees must be represented with 2 bytes: 5 bit for exponent, 11 bit for mantissa.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"StateAmount"),(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null},"*big.Int"),(0,r.kt)("td",{parentName:"tr",align:null},'State amount is represented as uint128 with a range from 0 to ~3.4 \xd7 10^38. It allows to represent up to 3.4 \xd7 10^20 "units" if standard Ethereum\'s 18 decimal symbols are used. This should be a sufficient range.')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Nonce"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"uint32"),(0,r.kt)("td",{parentName:"tr",align:null},"Nonce is the total number of executed transactions of the account. In order to apply the update of this state, it is necessary to indicate the current account nonce in the corresponding transaction, after which it will be automatically incremented. If you specify the wrong nonce, the changes will not occur.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"EthAddress"),(0,r.kt)("td",{parentName:"tr",align:null},"20"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"To make an BNB Smart Chain address from the BNB Smart Chain's public key, all we need to do is to apply Keccak-256 hash function to the key and then take the last 20 bytes of the result.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Signature"),(0,r.kt)("td",{parentName:"tr",align:null},"64"),(0,r.kt)("td",{parentName:"tr",align:null},"[]byte"),(0,r.kt)("td",{parentName:"tr",align:null},"Based on EDDSA.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"HashValue"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"hash value based on MiMC")))),(0,r.kt)("h3",{id:"amount-packing"},"Amount packing"),(0,r.kt)("p",null,"Mantissa and exponent parameters used in zkBNB:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"amount = mantissa * radix^{exponent}")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Exponent bit width"),(0,r.kt)("th",{parentName:"tr",align:null},"Mantissa bit width"),(0,r.kt)("th",{parentName:"tr",align:null},"Radix"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PackedTxAmount"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"35"),(0,r.kt)("td",{parentName:"tr",align:null},"10")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PackedFee"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"11"),(0,r.kt)("td",{parentName:"tr",align:null},"10")))),(0,r.kt)("h3",{id:"state-merkle-treeheight"},"State Merkle Tree(height)"),(0,r.kt)("p",null,"We have 3 unique trees: ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountTree(32)"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"NftTree(40)")," and one sub-tree ",(0,r.kt)("inlineCode",{parentName:"p"},"AssetTree(16)")," which\nbelongs to ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountTree(32)"),". The empty leaf for all the trees is just set every attribute as ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," for every node."),(0,r.kt)("h4",{id:"accounttree"},"AccountTree"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"AccountTree")," is used for storing all accounts info and the node of the account tree is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type AccountNode struct{\n    AccountNameHash string // bytes32\n    PubKey string // bytes32\n    Nonce int64\n    CollectionNonce int64\n    AssetRoot string // bytes32\n}\n")),(0,r.kt)("p",null,"Leaf hash computation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func ComputeAccountLeafHash(\n    accountNameHash string,\n    pk string,\n    nonce int64,\n    collectionNonce int64,\n    assetRoot []byte,\n) (hashVal []byte, err error) {\n    hFunc := mimc.NewMiMC()\n    var buf bytes.Buffer\n    buf.Write(common.FromHex(accountNameHash))\n    err = util.PaddingPkIntoBuf(&buf, pk)\n    if err != nil {\n        logx.Errorf("[ComputeAccountAssetLeafHash] unable to write pk into buf: %s", err.Error())\n        return nil, err\n    }\n    util.PaddingInt64IntoBuf(&buf, nonce)\n    util.PaddingInt64IntoBuf(&buf, collectionNonce)\n    buf.Write(assetRoot)\n    hFunc.Reset()\n    hFunc.Write(buf.Bytes())\n    hashVal = hFunc.Sum(nil)\n    return hashVal, nil\n}\n')),(0,r.kt)("h5",{id:"assettree"},"AssetTree"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"AssetTree")," is sub-tree of ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountTree")," and it stores all the assets ",(0,r.kt)("inlineCode",{parentName:"p"},"balance"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"offerCanceledOrFinalized"),". The node of asset tree is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type AssetNode struct {\n    Balance  string\n    OfferCanceledOrFinalized string // uint128\n}\n")),(0,r.kt)("p",null,"Leaf hash computation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func ComputeAccountAssetLeafHash(\n    balance string,\n    offerCanceledOrFinalized string,\n) (hashVal []byte, err error) {\n    hFunc := mimc.NewMiMC()\n    var buf bytes.Buffer\n    err = util.PaddingStringBigIntIntoBuf(&buf, balance)\n    if err != nil {\n        logx.Errorf("[ComputeAccountAssetLeafHash] invalid balance: %s", err.Error())\n        return nil, err\n    }\n    err = util.PaddingStringBigIntIntoBuf(&buf, offerCanceledOrFinalized)\n    if err != nil {\n        logx.Errorf("[ComputeAccountAssetLeafHash] invalid balance: %s", err.Error())\n        return nil, err\n    }\n    hFunc.Write(buf.Bytes())\n    return hFunc.Sum(nil), nil\n}\n')),(0,r.kt)("h4",{id:"nfttree"},"NftTree"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"NftTree")," is used for storing all the NFTs and the node info is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type NftNode struct {\n    CreatorAccountIndex int64\n    OwnerAccountIndex   int64\n    NftContentHash      string\n    NftL1Address        string\n    NftL1TokenId        string\n    CreatorTreasuryRate int64\n    CollectionId        int64 // 32 bit\n}\n")),(0,r.kt)("p",null,"Leaf hash computation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func ComputeNftAssetLeafHash(\n    creatorAccountIndex int64,\n    ownerAccountIndex int64,\n    nftContentHash string,\n    nftL1Address string,\n    nftL1TokenId string,\n    creatorTreasuryRate int64,\n    collectionId int64,\n) (hashVal []byte, err error) {\n    hFunc := mimc.NewMiMC()\n    var buf bytes.Buffer\n    util.PaddingInt64IntoBuf(&buf, creatorAccountIndex)\n    util.PaddingInt64IntoBuf(&buf, ownerAccountIndex)\n    buf.Write(ffmath.Mod(new(big.Int).SetBytes(common.FromHex(nftContentHash)), curve.Modulus).FillBytes(make([]byte, 32)))\n    err = util.PaddingAddressIntoBuf(&buf, nftL1Address)\n    if err != nil {\n        logx.Errorf("[ComputeNftAssetLeafHash] unable to write address to buf: %s", err.Error())\n        return nil, err\n    }\n    err = util.PaddingStringBigIntIntoBuf(&buf, nftL1TokenId)\n    if err != nil {\n        logx.Errorf("[ComputeNftAssetLeafHash] unable to write big int to buf: %s", err.Error())\n        return nil, err\n    }\n    util.PaddingInt64IntoBuf(&buf, creatorTreasuryRate)\n    util.PaddingInt64IntoBuf(&buf, collectionId)\n    hFunc.Write(buf.Bytes())\n    hashVal = hFunc.Sum(nil)\n    return hashVal, nil\n}\n')),(0,r.kt)("h4",{id:"stateroot"},"StateRoot"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"StateRoot")," is the final root that shows the final layer-2 state and will be stored on L1. It is computed by the root of ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountTree")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"NftTree"),". The computation of ",(0,r.kt)("inlineCode",{parentName:"p"},"StateRoot")," works as follows:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"StateRoot = MiMC(AccountRoot || NftRoot)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func ComputeStateRootHash(\n    accountRoot []byte,\n    nftRoot []byte,\n) []byte {\n    hFunc := mimc.NewMiMC()\n    hFunc.Write(accountRoot)\n    hFunc.Write(nftRoot)\n    return hFunc.Sum(nil)\n}\n")),(0,r.kt)("h2",{id:"zkbnb-transactions"},"zkBNB Transactions"),(0,r.kt)("p",null,"zkBNB transactions are divided into Rollup transactions (initiated inside Rollup by a Rollup account) and Priority operations (initiated on the BSC by an BNB Smart Chain account)."),(0,r.kt)("p",null,"Rollup transactions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"EmptyTx"),(0,r.kt)("li",{parentName:"ul"},"Transfer"),(0,r.kt)("li",{parentName:"ul"},"Withdraw"),(0,r.kt)("li",{parentName:"ul"},"CreateCollection"),(0,r.kt)("li",{parentName:"ul"},"MintNft"),(0,r.kt)("li",{parentName:"ul"},"TransferNft"),(0,r.kt)("li",{parentName:"ul"},"AtomicMatch"),(0,r.kt)("li",{parentName:"ul"},"CancelOffer"),(0,r.kt)("li",{parentName:"ul"},"WithdrawNft")),(0,r.kt)("p",null,"Priority operations:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"RegisterZNS"),(0,r.kt)("li",{parentName:"ul"},"Deposit"),(0,r.kt)("li",{parentName:"ul"},"DepositNft"),(0,r.kt)("li",{parentName:"ul"},"FullExit"),(0,r.kt)("li",{parentName:"ul"},"FullExitNft")),(0,r.kt)("h3",{id:"rollup-transaction-lifecycle"},"Rollup transaction lifecycle"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"User creates a ",(0,r.kt)("inlineCode",{parentName:"li"},"Transaction")," or a ",(0,r.kt)("inlineCode",{parentName:"li"},"Priority operation"),"."),(0,r.kt)("li",{parentName:"ol"},"After processing this request, committer creates a ",(0,r.kt)("inlineCode",{parentName:"li"},"Rollup operation")," and adds it to the block."),(0,r.kt)("li",{parentName:"ol"},"Once the block is complete, sender submits it to the zkBNB smart contract as a block commitment.\nPart of the logic of some ",(0,r.kt)("inlineCode",{parentName:"li"},"Rollup transaction")," is checked by the smart contract."),(0,r.kt)("li",{parentName:"ol"},"The proof for the block is submitted to the zkBNB smart contract as the block verification.\nIf the verification succeeds, the new state is considered finalized.")),(0,r.kt)("h3",{id:"emptytx"},"EmptyTx"),(0,r.kt)("h4",{id:"description"},"Description"),(0,r.kt)("p",null,"No effects."),(0,r.kt)("h4",{id:"on-chain-operation"},"On-Chain operation"),(0,r.kt)("h5",{id:"size"},"Size"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Chunks"),(0,r.kt)("th",{parentName:"tr",align:null},"Significant bytes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"1")))),(0,r.kt)("h5",{id:"structure"},"Structure"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Value/type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TxType"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"0x00")),(0,r.kt)("td",{parentName:"tr",align:null},"Transaction type")))),(0,r.kt)("h4",{id:"user-transaction"},"User transaction"),(0,r.kt)("p",null,"No user transaction"),(0,r.kt)("h3",{id:"registerzns"},"RegisterZNS"),(0,r.kt)("h4",{id:"description-1"},"Description"),(0,r.kt)("p",null,"This is a layer-1 transaction and a user needs to call this method first to register a layer-2 account."),(0,r.kt)("h4",{id:"on-chain-operation-1"},"On-Chain operation"),(0,r.kt)("h5",{id:"size-1"},"Size"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Chunks"),(0,r.kt)("th",{parentName:"tr",align:null},"Significant bytes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},"101")))),(0,r.kt)("h5",{id:"structure-1"},"Structure"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TxType"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"transaction type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"unique account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountName"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"account name")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountNameHash"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"hash value of the account name")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PubKeyX"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"layer-2 account's public key X")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PubKeyY"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"layer-2 account's public key Y")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func ConvertTxToRegisterZNSPubData(oTx *tx.Tx) (pubData []byte, err error) {\n    if oTx.TxType != commonTx.TxTypeRegisterZns {\n        logx.Errorf("[ConvertTxToRegisterZNSPubData] invalid tx type")\n        return nil, errors.New("[ConvertTxToRegisterZNSPubData] invalid tx type")\n    }\n    // parse tx\n    txInfo, err := commonTx.ParseRegisterZnsTxInfo(oTx.TxInfo)\n    if err != nil {\n        logx.Errorf("[ConvertTxToRegisterZNSPubData] unable to parse tx info: %s", err.Error())\n        return nil, err\n    }\n    var buf bytes.Buffer\n    buf.WriteByte(uint8(oTx.TxType))\n    buf.Write(Uint32ToBytes(uint32(txInfo.AccountIndex)))\n    chunk := SuffixPaddingBufToChunkSize(buf.Bytes())\n    buf.Reset()\n    buf.Write(chunk)\n    buf.Write(PrefixPaddingBufToChunkSize(AccountNameToBytes32(txInfo.AccountName)))\n    buf.Write(PrefixPaddingBufToChunkSize(txInfo.AccountNameHash))\n    pk, err := ParsePubKey(txInfo.PubKey)\n    if err != nil {\n        logx.Errorf("[ConvertTxToRegisterZNSPubData] unable to parse pub key: %s", err.Error())\n        return nil, err\n    }\n    // because we can get Y from X, so we only need to store X is enough\n    buf.Write(PrefixPaddingBufToChunkSize(pk.A.X.Marshal()))\n    buf.Write(PrefixPaddingBufToChunkSize(pk.A.Y.Marshal()))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    return buf.Bytes(), nil\n}\n')),(0,r.kt)("h4",{id:"user-transaction-1"},"User transaction"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountName"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"account name")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Owner"),(0,r.kt)("td",{parentName:"tr",align:null},"20"),(0,r.kt)("td",{parentName:"tr",align:null},"account layer-1 address")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PubKey"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"layer-2 account's public key")))),(0,r.kt)("h4",{id:"circuit"},"Circuit"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func VerifyRegisterZNSTx(\n    api API, flag Variable,\n    tx RegisterZnsTxConstraints,\n    accountsBefore [NbAccountsPerTx]AccountConstraints,\n) (pubData [PubDataSizePerTx]Variable) {\n    pubData = CollectPubDataFromRegisterZNS(api, tx)\n    CheckEmptyAccountNode(api, flag, accountsBefore[0])\n    return pubData\n}\n")),(0,r.kt)("h3",{id:"deposit"},"Deposit"),(0,r.kt)("h4",{id:"description-2"},"Description"),(0,r.kt)("p",null,"This is a layer-1 transaction and is used for depositing assets into the layer-2 account."),(0,r.kt)("h4",{id:"on-chain-operation-2"},"On-Chain operation"),(0,r.kt)("h5",{id:"size-2"},"Size"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Chunks"),(0,r.kt)("th",{parentName:"tr",align:null},"Significant bytes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},"55")))),(0,r.kt)("h5",{id:"structure-2"},"Structure"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TxType"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"transaction type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AssetId"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"asset index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AssetAmount"),(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null},"state amount")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountNameHash"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"account name hash")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func ConvertTxToDepositPubData(oTx *tx.Tx) (pubData []byte, err error) {\n    if oTx.TxType != commonTx.TxTypeDeposit {\n        logx.Errorf("[ConvertTxToDepositPubData] invalid tx type")\n        return nil, errors.New("[ConvertTxToDepositPubData] invalid tx type")\n    }\n    // parse tx\n    txInfo, err := commonTx.ParseDepositTxInfo(oTx.TxInfo)\n    if err != nil {\n        logx.Errorf("[ConvertTxToDepositPubData] unable to parse tx info: %s", err.Error())\n        return nil, err\n    }\n    var buf bytes.Buffer\n    buf.WriteByte(uint8(oTx.TxType))\n    buf.Write(Uint32ToBytes(uint32(txInfo.AccountIndex)))\n    buf.Write(Uint16ToBytes(uint16(txInfo.AssetId)))\n    buf.Write(Uint128ToBytes(txInfo.AssetAmount))\n    chunk1 := SuffixPaddingBufToChunkSize(buf.Bytes())\n    buf.Reset()\n    buf.Write(chunk1)\n    buf.Write(PrefixPaddingBufToChunkSize(txInfo.AccountNameHash))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    return buf.Bytes(), nil\n}\n')),(0,r.kt)("h4",{id:"user-transaction-2"},"User transaction"),(0,r.kt)("h5",{id:"depositbnb"},"DepositBNB"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountNameHash"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"account name hash")))),(0,r.kt)("h5",{id:"depositbep20"},"DepositBEP20"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AssetAddress"),(0,r.kt)("td",{parentName:"tr",align:null},"20"),(0,r.kt)("td",{parentName:"tr",align:null},"asset layer-1 address")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Amount"),(0,r.kt)("td",{parentName:"tr",align:null},"13"),(0,r.kt)("td",{parentName:"tr",align:null},"asset layer-1 amount")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountNameHash"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"account name hash")))),(0,r.kt)("h4",{id:"circuit-1"},"Circuit"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func VerifyDepositTx(\n    api API, flag Variable,\n    tx DepositTxConstraints,\n    accountsBefore [NbAccountsPerTx]AccountConstraints,\n) (pubData [PubDataSizePerTx]Variable) {\n    pubData = CollectPubDataFromDeposit(api, tx)\n    // verify params\n    IsVariableEqual(api, flag, tx.AccountNameHash, accountsBefore[0].AccountNameHash)\n    IsVariableEqual(api, flag, tx.AccountIndex, accountsBefore[0].AccountIndex)\n    IsVariableEqual(api, flag, tx.AssetId, accountsBefore[0].AssetsInfo[0].AssetId)\n    return pubData\n}\n")),(0,r.kt)("h3",{id:"depositnft"},"DepositNft"),(0,r.kt)("h4",{id:"description-3"},"Description"),(0,r.kt)("p",null,"This is a layer-1 transaction and is used for depositing NFTs into the layer-2 account."),(0,r.kt)("h4",{id:"on-chain-operation-3"},"On-Chain operation"),(0,r.kt)("h5",{id:"size-3"},"Size"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Chunks"),(0,r.kt)("th",{parentName:"tr",align:null},"Significant bytes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},"134")))),(0,r.kt)("h5",{id:"structure-3"},"Structure"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TxType"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"transaction type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NftIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"unique index of a nft")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NftL1Address"),(0,r.kt)("td",{parentName:"tr",align:null},"20"),(0,r.kt)("td",{parentName:"tr",align:null},"nft layer-1 address")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CreatorAccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"creator account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CreatorTreasuryRate"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"creator treasury rate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CollectionId"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"collection id")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NftContentHash"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"nft content hash")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NftL1TokenId"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"nft layer-1 token id")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountNameHash"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"account name hash")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func ConvertTxToDepositNftPubData(oTx *tx.Tx) (pubData []byte, err error) {\n    if oTx.TxType != commonTx.TxTypeDepositNft {\n        logx.Errorf("[ConvertTxToDepositNftPubData] invalid tx type")\n        return nil, errors.New("[ConvertTxToDepositNftPubData] invalid tx type")\n    }\n    // parse tx\n    txInfo, err := commonTx.ParseDepositNftTxInfo(oTx.TxInfo)\n    if err != nil {\n        logx.Errorf("[ConvertTxToDepositNftPubData] unable to parse tx info: %s", err.Error())\n        return nil, err\n    }\n    var buf bytes.Buffer\n    buf.WriteByte(uint8(oTx.TxType))\n    buf.Write(Uint32ToBytes(uint32(txInfo.AccountIndex)))\n    buf.Write(Uint40ToBytes(txInfo.NftIndex))\n    buf.Write(AddressStrToBytes(txInfo.NftL1Address))\n    chunk1 := SuffixPaddingBufToChunkSize(buf.Bytes())\n    buf.Reset()\n    buf.Write(Uint32ToBytes(uint32(txInfo.CreatorAccountIndex)))\n    buf.Write(Uint16ToBytes(uint16(txInfo.CreatorTreasuryRate)))\n    buf.Write(Uint16ToBytes(uint16(txInfo.CollectionId)))\n    chunk2 := PrefixPaddingBufToChunkSize(buf.Bytes())\n    buf.Reset()\n    buf.Write(chunk1)\n    buf.Write(chunk2)\n    buf.Write(PrefixPaddingBufToChunkSize(txInfo.NftContentHash))\n    buf.Write(Uint256ToBytes(txInfo.NftL1TokenId))\n    buf.Write(PrefixPaddingBufToChunkSize(txInfo.AccountNameHash))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    return buf.Bytes(), nil\n}\n')),(0,r.kt)("h4",{id:"user-transaction-3"},"User transaction"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountNameHash"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"account name hash")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AssetAddress"),(0,r.kt)("td",{parentName:"tr",align:null},"20"),(0,r.kt)("td",{parentName:"tr",align:null},"nft contract layer-1 address")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NftTokenId"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"nft layer-1 token id")))),(0,r.kt)("h4",{id:"circuit-2"},"Circuit"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func VerifyDepositNftTx(\n    api API,\n    flag Variable,\n    tx DepositNftTxConstraints,\n    accountsBefore [NbAccountsPerTx]AccountConstraints,\n    nftBefore NftConstraints,\n) (pubData [PubDataSizePerTx]Variable) {\n    pubData = CollectPubDataFromDepositNft(api, tx)\n    // verify params\n    // check empty nft\n    CheckEmptyNftNode(api, flag, nftBefore)\n    // account index\n    IsVariableEqual(api, flag, tx.AccountIndex, accountsBefore[0].AccountIndex)\n    // account name hash\n    IsVariableEqual(api, flag, tx.AccountNameHash, accountsBefore[0].AccountNameHash)\n    return pubData\n}\n")),(0,r.kt)("h3",{id:"transfer"},"Transfer"),(0,r.kt)("h4",{id:"description-4"},"Description"),(0,r.kt)("p",null,"This is a layer-2 transaction and is used for transferring assets in the layer-2 network."),(0,r.kt)("h4",{id:"on-chain-operation-4"},"On-Chain operation"),(0,r.kt)("h5",{id:"size-4"},"Size"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Chunks"),(0,r.kt)("th",{parentName:"tr",align:null},"Significant bytes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},"56")))),(0,r.kt)("h5",{id:"structure-4"},"Structure"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TxType"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"transaction type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"FromAccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"from account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ToAccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"receiver account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AssetId"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"asset index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AssetAmount"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"packed asset amount")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"gas fee account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAssetId"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"gas fee asset id")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAssetAmount"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"packed fee amount")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CallDataHash"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"call data hash")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func ConvertTxToTransferPubData(oTx *tx.Tx) (pubData []byte, err error) {\n    if oTx.TxType != commonTx.TxTypeTransfer {\n        logx.Errorf("[ConvertTxToTransferPubData] invalid tx type")\n        return nil, errors.New("[ConvertTxToTransferPubData] invalid tx type")\n    }\n    // parse tx\n    txInfo, err := commonTx.ParseTransferTxInfo(oTx.TxInfo)\n    if err != nil {\n        logx.Errorf("[ConvertTxToDepositPubData] unable to parse tx info: %s", err.Error())\n        return nil, err\n    }\n    var buf bytes.Buffer\n    buf.WriteByte(uint8(oTx.TxType))\n    buf.Write(Uint32ToBytes(uint32(txInfo.FromAccountIndex)))\n    buf.Write(Uint32ToBytes(uint32(txInfo.ToAccountIndex)))\n    buf.Write(Uint16ToBytes(uint16(txInfo.AssetId)))\n    packedAmountBytes, err := AmountToPackedAmountBytes(txInfo.AssetAmount)\n    if err != nil {\n        logx.Errorf("[ConvertTxToDepositPubData] unable to convert amount to packed amount: %s", err.Error())\n        return nil, err\n    }\n    buf.Write(packedAmountBytes)\n    buf.Write(Uint32ToBytes(uint32(txInfo.GasAccountIndex)))\n    buf.Write(Uint16ToBytes(uint16(txInfo.GasFeeAssetId)))\n    packedFeeBytes, err := FeeToPackedFeeBytes(txInfo.GasFeeAssetAmount)\n    if err != nil {\n        logx.Errorf("[ConvertTxToDepositPubData] unable to convert amount to packed fee amount: %s", err.Error())\n        return nil, err\n    }\n    buf.Write(packedFeeBytes)\n    chunk := SuffixPaddingBufToChunkSize(buf.Bytes())\n    buf.Reset()\n    buf.Write(chunk)\n    buf.Write(PrefixPaddingBufToChunkSize(txInfo.CallDataHash))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    pubData = buf.Bytes()\n    return pubData, nil\n}\n')),(0,r.kt)("h4",{id:"user-transaction-4"},"User transaction"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type TransferTxInfo struct {\n    FromAccountIndex  int64\n    ToAccountIndex    int64\n    ToAccountNameHash string\n    AssetId           int64\n    AssetAmount       *big.Int\n    GasAccountIndex   int64\n    GasFeeAssetId     int64\n    GasFeeAssetAmount *big.Int\n    Memo              string\n    CallData          string\n    CallDataHash      []byte\n    ExpiredAt         int64\n    Nonce             int64\n    Sig               []byte\n}\n")),(0,r.kt)("h4",{id:"circuit-3"},"Circuit"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func VerifyTransferTx(\n    api API, flag Variable,\n    tx *TransferTxConstraints,\n    accountsBefore [NbAccountsPerTx]AccountConstraints,\n) (pubData [PubDataSizePerTx]Variable) {\n    // collect pub-data\n    pubData = CollectPubDataFromTransfer(api, *tx)\n    // verify params\n    // account index\n    IsVariableEqual(api, flag, tx.FromAccountIndex, accountsBefore[0].AccountIndex)\n    IsVariableEqual(api, flag, tx.ToAccountIndex, accountsBefore[1].AccountIndex)\n    IsVariableEqual(api, flag, tx.GasAccountIndex, accountsBefore[2].AccountIndex)\n    // account name hash\n    IsVariableEqual(api, flag, tx.ToAccountNameHash, accountsBefore[1].AccountNameHash)\n    // asset id\n    IsVariableEqual(api, flag, tx.AssetId, accountsBefore[0].AssetsInfo[0].AssetId)\n    IsVariableEqual(api, flag, tx.AssetId, accountsBefore[1].AssetsInfo[0].AssetId)\n    // gas asset id\n    IsVariableEqual(api, flag, tx.GasFeeAssetId, accountsBefore[0].AssetsInfo[1].AssetId)\n    IsVariableEqual(api, flag, tx.GasFeeAssetId, accountsBefore[2].AssetsInfo[0].AssetId)\n    // should have enough balance\n    tx.AssetAmount = UnpackAmount(api, tx.AssetAmount)\n    tx.GasFeeAssetAmount = UnpackFee(api, tx.GasFeeAssetAmount)\n    //tx.GasFeeAssetAmount = UnpackFee(api, tx.GasFeeAssetAmount)\n    IsVariableLessOrEqual(api, flag, tx.AssetAmount, accountsBefore[0].AssetsInfo[0].Balance)\n    IsVariableLessOrEqual(api, flag, tx.GasFeeAssetAmount, accountsBefore[0].AssetsInfo[1].Balance)\n    return pubData\n}\n")),(0,r.kt)("h3",{id:"withdraw"},"Withdraw"),(0,r.kt)("h4",{id:"description-5"},"Description"),(0,r.kt)("p",null,"This is a layer-2 transaction and is used for withdrawing assets from the layer-2 to the layer-1."),(0,r.kt)("h4",{id:"on-chain-operation-5"},"On-Chain operation"),(0,r.kt)("h5",{id:"size-5"},"Size"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Chunks"),(0,r.kt)("th",{parentName:"tr",align:null},"Significant bytes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},"51")))),(0,r.kt)("h5",{id:"structure-5"},"Structure"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TxType"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"transaction type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"from account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ToAddress"),(0,r.kt)("td",{parentName:"tr",align:null},"20"),(0,r.kt)("td",{parentName:"tr",align:null},"layer-1 receiver address")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AssetId"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"asset index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AssetAmount"),(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null},"state amount")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"gas fee account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAssetId"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"gas fee asset id")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAssetAmount"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"packed fee amount")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func ConvertTxToWithdrawPubData(oTx *tx.Tx) (pubData []byte, err error) {\n    if oTx.TxType != commonTx.TxTypeWithdraw {\n        logx.Errorf("[ConvertTxToWithdrawPubData] invalid tx type")\n        return nil, errors.New("[ConvertTxToWithdrawPubData] invalid tx type")\n    }\n    // parse tx\n    txInfo, err := commonTx.ParseWithdrawTxInfo(oTx.TxInfo)\n    if err != nil {\n        logx.Errorf("[ConvertTxToWithdrawPubData] unable to parse tx info: %s", err.Error())\n        return nil, err\n    }\n    var buf bytes.Buffer\n    buf.WriteByte(uint8(oTx.TxType))\n    buf.Write(Uint32ToBytes(uint32(txInfo.FromAccountIndex)))\n    buf.Write(AddressStrToBytes(txInfo.ToAddress))\n    buf.Write(Uint16ToBytes(uint16(txInfo.AssetId)))\n    chunk1 := SuffixPaddingBufToChunkSize(buf.Bytes())\n    buf.Reset()\n    buf.Write(Uint128ToBytes(txInfo.AssetAmount))\n    buf.Write(Uint32ToBytes(uint32(txInfo.GasAccountIndex)))\n    buf.Write(Uint16ToBytes(uint16(txInfo.GasFeeAssetId)))\n    packedFeeBytes, err := FeeToPackedFeeBytes(txInfo.GasFeeAssetAmount)\n    if err != nil {\n        logx.Errorf("[ConvertTxToDepositPubData] unable to convert amount to packed fee amount: %s", err.Error())\n        return nil, err\n    }\n    buf.Write(packedFeeBytes)\n    chunk2 := PrefixPaddingBufToChunkSize(buf.Bytes())\n    buf.Reset()\n    buf.Write(chunk1)\n    buf.Write(chunk2)\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    return buf.Bytes(), nil\n}\n')),(0,r.kt)("h4",{id:"user-transaction-5"},"User transaction"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type WithdrawTxInfo struct {\n    FromAccountIndex  int64\n    AssetId           int64\n    AssetAmount       *big.Int\n    GasAccountIndex   int64\n    GasFeeAssetId     int64\n    GasFeeAssetAmount *big.Int\n    ToAddress         string\n    ExpiredAt         int64\n    Nonce             int64\n    Sig               []byte\n}\n")),(0,r.kt)("h4",{id:"circuit-4"},"Circuit"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func VerifyWithdrawTx(\n    api API, flag Variable,\n    tx *WithdrawTxConstraints,\n    accountsBefore [NbAccountsPerTx]AccountConstraints,\n) (pubData [PubDataSizePerTx]Variable) {\n    pubData = CollectPubDataFromWithdraw(api, *tx)\n    // verify params\n    // account index\n    IsVariableEqual(api, flag, tx.FromAccountIndex, accountsBefore[0].AccountIndex)\n    IsVariableEqual(api, flag, tx.GasAccountIndex, accountsBefore[1].AccountIndex)\n    // asset id\n    IsVariableEqual(api, flag, tx.AssetId, accountsBefore[0].AssetsInfo[0].AssetId)\n    IsVariableEqual(api, flag, tx.GasFeeAssetId, accountsBefore[0].AssetsInfo[1].AssetId)\n    IsVariableEqual(api, flag, tx.GasFeeAssetId, accountsBefore[1].AssetsInfo[0].AssetId)\n    // should have enough assets\n    tx.GasFeeAssetAmount = UnpackFee(api, tx.GasFeeAssetAmount)\n    IsVariableLessOrEqual(api, flag, tx.AssetAmount, accountsBefore[0].AssetsInfo[0].Balance)\n    IsVariableLessOrEqual(api, flag, tx.GasFeeAssetAmount, accountsBefore[0].AssetsInfo[1].Balance)\n    return pubData\n}\n")),(0,r.kt)("h3",{id:"createcollection"},"CreateCollection"),(0,r.kt)("h4",{id:"description-6"},"Description"),(0,r.kt)("p",null,"This is a layer-2 transaction and is used for creating a new collection"),(0,r.kt)("h4",{id:"on-chain-operation-6"},"On-Chain operation"),(0,r.kt)("h5",{id:"size-6"},"Size"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Chunks"),(0,r.kt)("th",{parentName:"tr",align:null},"Significant bytes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},"15")))),(0,r.kt)("h5",{id:"structure-6"},"Structure"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TxType"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"transaction type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CollectionId"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"collection index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasAccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"gas account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAssetId"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"asset id")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAssetAmount"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"packed fee amount")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func ConvertTxToCreateCollectionPubData(oTx *tx.Tx) (pubData []byte, err error) {\n    if oTx.TxType != commonTx.TxTypeCreateCollection {\n        logx.Errorf("[ConvertTxToCreateCollectionPubData] invalid tx type")\n        return nil, errors.New("[ConvertTxToCreateCollectionPubData] invalid tx type")\n    }\n    // parse tx\n    txInfo, err := commonTx.ParseCreateCollectionTxInfo(oTx.TxInfo)\n    if err != nil {\n        logx.Errorf("[ConvertTxToCreateCollectionPubData] unable to parse tx info: %s", err.Error())\n        return nil, err\n    }\n    var buf bytes.Buffer\n    buf.WriteByte(uint8(oTx.TxType))\n    buf.Write(Uint32ToBytes(uint32(txInfo.AccountIndex)))\n    buf.Write(Uint16ToBytes(uint16(txInfo.CollectionId)))\n    buf.Write(Uint32ToBytes(uint32(txInfo.GasAccountIndex)))\n    buf.Write(Uint16ToBytes(uint16(txInfo.GasFeeAssetId)))\n    packedFeeBytes, err := FeeToPackedFeeBytes(txInfo.GasFeeAssetAmount)\n    if err != nil {\n        logx.Errorf("[ConvertTxToDepositPubData] unable to convert amount to packed fee amount: %s", err.Error())\n        return nil, err\n    }\n    buf.Write(packedFeeBytes)\n    chunk := SuffixPaddingBufToChunkSize(buf.Bytes())\n    buf.Reset()\n    buf.Write(chunk)\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    return buf.Bytes(), nil\n}\n')),(0,r.kt)("h4",{id:"user-transaction-6"},"User transaction"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type CreateCollectionTxInfo struct {\n    AccountIndex      int64\n    CollectionId      int64\n    Name              string\n    Introduction      string\n    GasAccountIndex   int64\n    GasFeeAssetId     int64\n    GasFeeAssetAmount *big.Int\n    ExpiredAt         int64\n    Nonce             int64\n    Sig               []byte\n}\n")),(0,r.kt)("h4",{id:"circuit-5"},"Circuit"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func VerifyCreateCollectionTx(\n    api API, flag Variable,\n    tx *CreateCollectionTxConstraints,\n    accountsBefore [NbAccountsPerTx]AccountConstraints,\n) (pubData [PubDataSizePerTx]Variable) {\n    pubData = CollectPubDataFromCreateCollection(api, *tx)\n    // verify params\n    IsVariableLessOrEqual(api, flag, tx.CollectionId, 65535)\n    // account index\n    IsVariableEqual(api, flag, tx.AccountIndex, accountsBefore[0].AccountIndex)\n    IsVariableEqual(api, flag, tx.GasAccountIndex, accountsBefore[1].AccountIndex)\n    // asset id\n    IsVariableEqual(api, flag, tx.GasFeeAssetId, accountsBefore[0].AssetsInfo[0].AssetId)\n    IsVariableEqual(api, flag, tx.GasFeeAssetId, accountsBefore[1].AssetsInfo[0].AssetId)\n    // collection id\n    IsVariableEqual(api, flag, tx.CollectionId, api.Add(accountsBefore[0].CollectionNonce, 1))\n    // should have enough assets\n    tx.GasFeeAssetAmount = UnpackAmount(api, tx.GasFeeAssetAmount)\n    IsVariableLessOrEqual(api, flag, tx.GasFeeAssetAmount, accountsBefore[0].AssetsInfo[0].Balance)\n    return pubData\n}\n")),(0,r.kt)("h3",{id:"mintnft"},"MintNft"),(0,r.kt)("h4",{id:"description-7"},"Description"),(0,r.kt)("p",null,"This is a layer-2 transaction and is used for minting NFTs in the layer-2 network."),(0,r.kt)("h4",{id:"on-chain-operation-7"},"On-Chain operation"),(0,r.kt)("h5",{id:"size-7"},"Size"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Chunks"),(0,r.kt)("th",{parentName:"tr",align:null},"Significant bytes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},"58")))),(0,r.kt)("h5",{id:"structure-7"},"Structure"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TxType"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"transaction type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CreatorAccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"creator account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ToAccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"receiver account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NftIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"unique nft index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"gas fee account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAssetId"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"gas fee asset id")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAssetAmount"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"packed fee amount")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CreatorTreasuryRate"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"creator treasury rate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CollectionId"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"collection index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NftContentHash"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"nft content hash")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func ConvertTxToMintNftPubData(oTx *tx.Tx) (pubData []byte, err error) {\n    if oTx.TxType != commonTx.TxTypeMintNft {\n        logx.Errorf("[ConvertTxToMintNftPubData] invalid tx type")\n        return nil, errors.New("[ConvertTxToMintNftPubData] invalid tx type")\n    }\n    // parse tx\n    txInfo, err := commonTx.ParseMintNftTxInfo(oTx.TxInfo)\n    if err != nil {\n        logx.Errorf("[ConvertTxToMintNftPubData] unable to parse tx info: %s", err.Error())\n        return nil, err\n    }\n    var buf bytes.Buffer\n    buf.WriteByte(uint8(oTx.TxType))\n    buf.Write(Uint32ToBytes(uint32(txInfo.CreatorAccountIndex)))\n    buf.Write(Uint32ToBytes(uint32(txInfo.ToAccountIndex)))\n    buf.Write(Uint40ToBytes(txInfo.NftIndex))\n    buf.Write(Uint32ToBytes(uint32(txInfo.GasAccountIndex)))\n    buf.Write(Uint16ToBytes(uint16(txInfo.GasFeeAssetId)))\n    packedFeeBytes, err := FeeToPackedFeeBytes(txInfo.GasFeeAssetAmount)\n    if err != nil {\n        logx.Errorf("[ConvertTxToDepositPubData] unable to convert amount to packed fee amount: %s", err.Error())\n        return nil, err\n    }\n    buf.Write(packedFeeBytes)\n    buf.Write(Uint16ToBytes(uint16(txInfo.CreatorTreasuryRate)))\n    buf.Write(Uint16ToBytes(uint16(txInfo.NftCollectionId)))\n    chunk := SuffixPaddingBufToChunkSize(buf.Bytes())\n    buf.Reset()\n    buf.Write(chunk)\n    buf.Write(PrefixPaddingBufToChunkSize(common.FromHex(txInfo.NftContentHash)))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    return buf.Bytes(), nil\n}\n')),(0,r.kt)("h4",{id:"user-transaction-7"},"User transaction"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type MintNftTxInfo struct {\n    CreatorAccountIndex int64\n    ToAccountIndex      int64\n    ToAccountNameHash   string\n    NftIndex            int64\n    NftContentHash      string\n    NftCollectionId     int64\n    CreatorTreasuryRate int64\n    GasAccountIndex     int64\n    GasFeeAssetId       int64\n    GasFeeAssetAmount   *big.Int\n    ExpiredAt           int64\n    Nonce               int64\n    Sig                 []byte\n}\n")),(0,r.kt)("h4",{id:"circuit-6"},"Circuit"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func VerifyMintNftTx(\n    api API, flag Variable,\n    tx *MintNftTxConstraints,\n    accountsBefore [NbAccountsPerTx]AccountConstraints, nftBefore NftConstraints,\n) (pubData [PubDataSizePerTx]Variable) {\n    pubData = CollectPubDataFromMintNft(api, *tx)\n    // verify params\n    // check empty nft\n    CheckEmptyNftNode(api, flag, nftBefore)\n    // account index\n    IsVariableEqual(api, flag, tx.CreatorAccountIndex, accountsBefore[0].AccountIndex)\n    IsVariableEqual(api, flag, tx.ToAccountIndex, accountsBefore[1].AccountIndex)\n    IsVariableEqual(api, flag, tx.GasAccountIndex, accountsBefore[2].AccountIndex)\n    // account name hash\n    IsVariableEqual(api, flag, tx.ToAccountNameHash, accountsBefore[1].AccountNameHash)\n    // content hash\n    isZero := api.IsZero(tx.NftContentHash)\n    IsVariableEqual(api, flag, isZero, 0)\n    // gas asset id\n    IsVariableEqual(api, flag, tx.GasFeeAssetId, accountsBefore[0].AssetsInfo[0].AssetId)\n    IsVariableEqual(api, flag, tx.GasFeeAssetId, accountsBefore[2].AssetsInfo[0].AssetId)\n    // should have enough balance\n    tx.GasFeeAssetAmount = UnpackFee(api, tx.GasFeeAssetAmount)\n    IsVariableLessOrEqual(api, flag, tx.GasFeeAssetAmount, accountsBefore[0].AssetsInfo[0].Balance)\n    return pubData\n}\n")),(0,r.kt)("h3",{id:"transfernft"},"TransferNft"),(0,r.kt)("h4",{id:"description-8"},"Description"),(0,r.kt)("p",null,"This is a layer-2 transaction and is used for transferring NFTs to others in the layer-2 network."),(0,r.kt)("h4",{id:"on-chain-operation-8"},"On-Chain operation"),(0,r.kt)("h5",{id:"size-8"},"Size"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Chunks"),(0,r.kt)("th",{parentName:"tr",align:null},"Significant bytes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},"54")))),(0,r.kt)("h5",{id:"structure-8"},"Structure"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TxType"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"transaction type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"FromAccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"from account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ToAccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"receiver account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NftIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"unique nft index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"gas fee account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAssetId"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"gas fee asset id")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAssetAmount"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"packed fee amount")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CallDataHash"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"call data hash")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func ConvertTxToTransferNftPubData(oTx *tx.Tx) (pubData []byte, err error) {\n    if oTx.TxType != commonTx.TxTypeTransferNft {\n        logx.Errorf("[ConvertTxToMintNftPubData] invalid tx type")\n        return nil, errors.New("[ConvertTxToMintNftPubData] invalid tx type")\n    }\n    // parse tx\n    txInfo, err := commonTx.ParseTransferNftTxInfo(oTx.TxInfo)\n    if err != nil {\n        logx.Errorf("[ConvertTxToMintNftPubData] unable to parse tx info: %s", err.Error())\n        return nil, err\n    }\n    var buf bytes.Buffer\n    buf.WriteByte(uint8(oTx.TxType))\n    buf.Write(Uint32ToBytes(uint32(txInfo.FromAccountIndex)))\n    buf.Write(Uint32ToBytes(uint32(txInfo.ToAccountIndex)))\n    buf.Write(Uint40ToBytes(txInfo.NftIndex))\n    buf.Write(Uint32ToBytes(uint32(txInfo.GasAccountIndex)))\n    buf.Write(Uint16ToBytes(uint16(txInfo.GasFeeAssetId)))\n    packedFeeBytes, err := FeeToPackedFeeBytes(txInfo.GasFeeAssetAmount)\n    if err != nil {\n        logx.Errorf("[ConvertTxToDepositPubData] unable to convert amount to packed fee amount: %s", err.Error())\n        return nil, err\n    }\n    buf.Write(packedFeeBytes)\n    chunk := SuffixPaddingBufToChunkSize(buf.Bytes())\n    buf.Reset()\n    buf.Write(chunk)\n    buf.Write(PrefixPaddingBufToChunkSize(txInfo.CallDataHash))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    return buf.Bytes(), nil\n}\n')),(0,r.kt)("h4",{id:"user-transaction-8"},"User transaction"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type TransferNftTxInfo struct {\n    FromAccountIndex  int64\n    ToAccountIndex    int64\n    ToAccountNameHash string\n    NftIndex          int64\n    GasAccountIndex   int64\n    GasFeeAssetId     int64\n    GasFeeAssetAmount *big.Int\n    CallData          string\n    CallDataHash      []byte\n    ExpiredAt         int64\n    Nonce             int64\n    Sig               []byte\n}\n")),(0,r.kt)("h4",{id:"circuit-7"},"Circuit"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func VerifyTransferNftTx(\n    api API,\n    flag Variable,\n    tx *TransferNftTxConstraints,\n    accountsBefore [NbAccountsPerTx]AccountConstraints,\n    nftBefore NftConstraints,\n) (pubData [PubDataSizePerTx]Variable) {\n    pubData = CollectPubDataFromTransferNft(api, *tx)\n    // verify params\n    // account index\n    IsVariableEqual(api, flag, tx.FromAccountIndex, accountsBefore[0].AccountIndex)\n    IsVariableEqual(api, flag, tx.ToAccountIndex, accountsBefore[1].AccountIndex)\n    IsVariableEqual(api, flag, tx.GasAccountIndex, accountsBefore[2].AccountIndex)\n    // account name\n    IsVariableEqual(api, flag, tx.ToAccountNameHash, accountsBefore[1].AccountNameHash)\n    // asset id\n    IsVariableEqual(api, flag, tx.GasFeeAssetId, accountsBefore[0].AssetsInfo[0].AssetId)\n    IsVariableEqual(api, flag, tx.GasFeeAssetId, accountsBefore[2].AssetsInfo[0].AssetId)\n    // nft info\n    IsVariableEqual(api, flag, tx.NftIndex, nftBefore.NftIndex)\n    IsVariableEqual(api, flag, tx.FromAccountIndex, nftBefore.OwnerAccountIndex)\n    // should have enough balance\n    tx.GasFeeAssetAmount = UnpackFee(api, tx.GasFeeAssetAmount)\n    IsVariableLessOrEqual(api, flag, tx.GasFeeAssetAmount, accountsBefore[0].AssetsInfo[0].Balance)\n    return pubData\n}\n")),(0,r.kt)("h3",{id:"atomicmatch"},"AtomicMatch"),(0,r.kt)("h4",{id:"description-9"},"Description"),(0,r.kt)("p",null,"This is a layer-2 transaction that will be used for buying or selling Nft in the layer-2 network."),(0,r.kt)("h4",{id:"on-chain-operation-9"},"On-Chain operation"),(0,r.kt)("h5",{id:"size-9"},"Size"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Chunks"),(0,r.kt)("th",{parentName:"tr",align:null},"Significant bytes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},"44")))),(0,r.kt)("h5",{id:"structure-9"},"Structure"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Offer"),":"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Type"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"transaction type, 0 indicates this is a  ",(0,r.kt)("inlineCode",{parentName:"td"},"BuyNftOffer")," , 1 indicate this is a  ",(0,r.kt)("inlineCode",{parentName:"td"},"SellNftOffer"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"OfferId"),(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},"used to identify the o\ufb00er")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"who want to buy/sell nft")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AssetId"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"the asset id which buyer/seller want to use pay for nft")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AssetAmount"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"the asset amount")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ListedAt"),(0,r.kt)("td",{parentName:"tr",align:null},"8"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp when the order is signed")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ExpiredAt"),(0,r.kt)("td",{parentName:"tr",align:null},"8"),(0,r.kt)("td",{parentName:"tr",align:null},"timestamp after which the order is invalid")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Sig"),(0,r.kt)("td",{parentName:"tr",align:null},"64"),(0,r.kt)("td",{parentName:"tr",align:null},"signature generated by buyer/seller_account_index's private key")))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"AtomicMatch"),"(",(0,r.kt)("strong",{parentName:"p"},"below is the only info that will be uploaded on-chain"),"):"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TxType"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"transaction type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SubmitterAccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"submitter account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BuyerAccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"buyer account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BuyerOfferId"),(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},"used to identify the offer")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SellerAccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"seller account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SellerOfferId"),(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},"used to identify the offer")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AssetId"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"asset id")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AssetAmount"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"packed asset amount")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CreatorAmount"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"packed creator amount")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TreasuryAmount"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"packed treasury amount")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"gas fee account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAssetId"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"gas fee asset id")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAssetAmount"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"packed fee amount")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func ConvertTxToAtomicMatchPubData(oTx *tx.Tx) (pubData []byte, err error) {\n    if oTx.TxType != commonTx.TxTypeAtomicMatch {\n        logx.Errorf("[ConvertTxToAtomicMatchPubData] invalid tx type")\n        return nil, errors.New("[ConvertTxToAtomicMatchPubData] invalid tx type")\n    }\n    // parse tx\n    txInfo, err := commonTx.ParseAtomicMatchTxInfo(oTx.TxInfo)\n    if err != nil {\n        logx.Errorf("[ConvertTxToAtomicMatchPubData] unable to parse tx info: %s", err.Error())\n        return nil, err\n    }\n    var buf bytes.Buffer\n    buf.WriteByte(uint8(oTx.TxType))\n    buf.Write(Uint32ToBytes(uint32(txInfo.AccountIndex)))\n    buf.Write(Uint32ToBytes(uint32(txInfo.BuyOffer.AccountIndex)))\n    buf.Write(Uint24ToBytes(txInfo.BuyOffer.OfferId))\n    buf.Write(Uint32ToBytes(uint32(txInfo.SellOffer.AccountIndex)))\n    buf.Write(Uint24ToBytes(txInfo.SellOffer.OfferId))\n    buf.Write(Uint40ToBytes(txInfo.BuyOffer.NftIndex))\n    buf.Write(Uint16ToBytes(uint16(txInfo.SellOffer.AssetId)))\n    chunk1 := SuffixPaddingBufToChunkSize(buf.Bytes())\n    buf.Reset()\n    packedAmountBytes, err := AmountToPackedAmountBytes(txInfo.BuyOffer.AssetAmount)\n    if err != nil {\n        logx.Errorf("[ConvertTxToDepositPubData] unable to convert amount to packed amount: %s", err.Error())\n        return nil, err\n    }\n    buf.Write(packedAmountBytes)\n    creatorAmountBytes, err := AmountToPackedAmountBytes(txInfo.CreatorAmount)\n    if err != nil {\n        logx.Errorf("[ConvertTxToDepositPubData] unable to convert amount to packed amount: %s", err.Error())\n        return nil, err\n    }\n    buf.Write(creatorAmountBytes)\n    treasuryAmountBytes, err := AmountToPackedAmountBytes(txInfo.TreasuryAmount)\n    if err != nil {\n        logx.Errorf("[ConvertTxToDepositPubData] unable to convert amount to packed amount: %s", err.Error())\n        return nil, err\n    }\n    buf.Write(treasuryAmountBytes)\n    buf.Write(Uint32ToBytes(uint32(txInfo.GasAccountIndex)))\n    buf.Write(Uint16ToBytes(uint16(txInfo.GasFeeAssetId)))\n    packedFeeBytes, err := FeeToPackedFeeBytes(txInfo.GasFeeAssetAmount)\n    if err != nil {\n        logx.Errorf("[ConvertTxToDepositPubData] unable to convert amount to packed fee amount: %s", err.Error())\n        return nil, err\n    }\n    buf.Write(packedFeeBytes)\n    chunk2 := PrefixPaddingBufToChunkSize(buf.Bytes())\n    buf.Reset()\n    buf.Write(chunk1)\n    buf.Write(chunk2)\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    return buf.Bytes(), nil\n}\n')),(0,r.kt)("h4",{id:"user-transaction-9"},"User transaction"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type OfferTxInfo struct {\n    Type         int64\n    OfferId      int64\n    AccountIndex int64\n    NftIndex     int64\n    AssetId      int64\n    AssetAmount  *big.Int\n    ListedAt     int64\n    ExpiredAt    int64\n    TreasuryRate int64\n    Sig          []byte\n}\n\ntype AtomicMatchTxInfo struct {\n    AccountIndex      int64\n    BuyOffer          *OfferTxInfo\n    SellOffer         *OfferTxInfo\n    GasAccountIndex   int64\n    GasFeeAssetId     int64\n    GasFeeAssetAmount *big.Int\n    CreatorAmount     *big.Int\n    TreasuryAmount    *big.Int\n    Nonce             int64\n    ExpiredAt         int64\n    Sig               []byte\n}\n")),(0,r.kt)("h4",{id:"circuit-8"},"Circuit"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func VerifyAtomicMatchTx(\n    api API, flag Variable,\n    tx *AtomicMatchTxConstraints,\n    accountsBefore [NbAccountsPerTx]AccountConstraints,\n    nftBefore NftConstraints,\n    blockCreatedAt Variable,\n    hFunc MiMC,\n) (pubData [PubDataSizePerTx]Variable, err error) {\n    pubData = CollectPubDataFromAtomicMatch(api, *tx)\n    // verify params\n    IsVariableEqual(api, flag, tx.BuyOffer.Type, 0)\n    IsVariableEqual(api, flag, tx.SellOffer.Type, 1)\n    IsVariableEqual(api, flag, tx.BuyOffer.AssetId, tx.SellOffer.AssetId)\n    IsVariableEqual(api, flag, tx.BuyOffer.AssetAmount, tx.SellOffer.AssetAmount)\n    IsVariableEqual(api, flag, tx.BuyOffer.NftIndex, tx.SellOffer.NftIndex)\n    IsVariableEqual(api, flag, tx.BuyOffer.AssetId, accountsBefore[1].AssetsInfo[0].AssetId)\n    IsVariableEqual(api, flag, tx.SellOffer.AssetId, accountsBefore[2].AssetsInfo[0].AssetId)\n    IsVariableEqual(api, flag, tx.SellOffer.AssetId, accountsBefore[3].AssetsInfo[0].AssetId)\n    IsVariableEqual(api, flag, tx.GasAccountIndex, accountsBefore[4].AccountIndex)\n    IsVariableEqual(api, flag, tx.GasFeeAssetId, accountsBefore[0].AssetsInfo[0].AssetId)\n    IsVariableEqual(api, flag, tx.GasFeeAssetId, accountsBefore[4].AssetsInfo[1].AssetId)\n    IsVariableLessOrEqual(api, flag, blockCreatedAt, tx.BuyOffer.ExpiredAt)\n    IsVariableLessOrEqual(api, flag, blockCreatedAt, tx.SellOffer.ExpiredAt)\n    IsVariableEqual(api, flag, nftBefore.NftIndex, tx.SellOffer.NftIndex)\n    IsVariableEqual(api, flag, tx.BuyOffer.TreasuryRate, tx.SellOffer.TreasuryRate)\n    // verify signature\n    hFunc.Reset()\n    buyOfferHash := ComputeHashFromOfferTx(tx.BuyOffer, hFunc)\n    hFunc.Reset()\n    notBuyer := api.IsZero(api.IsZero(api.Sub(tx.AccountIndex, tx.BuyOffer.AccountIndex)))\n    notBuyer = api.And(flag, notBuyer)\n    err = VerifyEddsaSig(notBuyer, api, hFunc, buyOfferHash, accountsBefore[1].AccountPk, tx.BuyOffer.Sig)\n    if err != nil {\n        return pubData, err\n    }\n    hFunc.Reset()\n    sellOfferHash := ComputeHashFromOfferTx(tx.SellOffer, hFunc)\n    hFunc.Reset()\n    notSeller := api.IsZero(api.IsZero(api.Sub(tx.AccountIndex, tx.SellOffer.AccountIndex)))\n    notSeller = api.And(flag, notSeller)\n    err = VerifyEddsaSig(notSeller, api, hFunc, sellOfferHash, accountsBefore[2].AccountPk, tx.SellOffer.Sig)\n    if err != nil {\n        return pubData, err\n    }\n    // verify account index\n    // submitter\n    IsVariableEqual(api, flag, tx.AccountIndex, accountsBefore[0].AccountIndex)\n    // buyer\n    IsVariableEqual(api, flag, tx.BuyOffer.AccountIndex, accountsBefore[1].AccountIndex)\n    // seller\n    IsVariableEqual(api, flag, tx.SellOffer.AccountIndex, accountsBefore[2].AccountIndex)\n    // creator\n    IsVariableEqual(api, flag, nftBefore.CreatorAccountIndex, accountsBefore[3].AccountIndex)\n    // gas\n    IsVariableEqual(api, flag, tx.GasAccountIndex, accountsBefore[4].AccountIndex)\n    // verify buy offer id\n    buyOfferIdBits := api.ToBinary(tx.BuyOffer.OfferId, 24)\n    buyAssetId := api.FromBinary(buyOfferIdBits[7:]...)\n    buyOfferIndex := api.Sub(tx.BuyOffer.OfferId, api.Mul(buyAssetId, OfferSizePerAsset))\n    buyOfferIndexBits := api.ToBinary(accountsBefore[1].AssetsInfo[1].OfferCanceledOrFinalized, OfferSizePerAsset)\n    for i := 0; i < OfferSizePerAsset; i++ {\n        isZero := api.IsZero(api.Sub(buyOfferIndex, i))\n        isCheckVar := api.And(isZero, flag)\n        isCheck := api.Compiler().IsBoolean(isCheckVar)\n        if isCheck {\n            IsVariableEqual(api, 1, buyOfferIndexBits[i], 0)\n        }\n    }\n    // verify sell offer id\n    sellOfferIdBits := api.ToBinary(tx.SellOffer.OfferId, 24)\n    sellAssetId := api.FromBinary(sellOfferIdBits[7:]...)\n    sellOfferIndex := api.Sub(tx.SellOffer.OfferId, api.Mul(sellAssetId, OfferSizePerAsset))\n    sellOfferIndexBits := api.ToBinary(accountsBefore[2].AssetsInfo[1].OfferCanceledOrFinalized, OfferSizePerAsset)\n    for i := 0; i < OfferSizePerAsset; i++ {\n        isZero := api.IsZero(api.Sub(sellOfferIndex, i))\n        isCheckVar := api.And(isZero, flag)\n        isCheck := api.Compiler().IsBoolean(isCheckVar)\n        if isCheck {\n            IsVariableEqual(api, 1, sellOfferIndexBits[i], 0)\n        }\n    }\n    // buyer should have enough balance\n    tx.BuyOffer.AssetAmount = UnpackAmount(api, tx.BuyOffer.AssetAmount)\n    IsVariableLessOrEqual(api, flag, tx.BuyOffer.AssetAmount, accountsBefore[1].AssetsInfo[0].Balance)\n    // submitter should have enough balance\n    tx.GasFeeAssetAmount = UnpackFee(api, tx.GasFeeAssetAmount)\n    IsVariableLessOrEqual(api, flag, tx.GasFeeAssetAmount, accountsBefore[0].AssetsInfo[0].Balance)\n    return pubData, nil\n}\n")),(0,r.kt)("h3",{id:"canceloffer"},"CancelOffer"),(0,r.kt)("h4",{id:"description-10"},"Description"),(0,r.kt)("p",null,"This is a layer-2 transaction and is used for canceling nft offer."),(0,r.kt)("h4",{id:"on-chain-operation-10"},"On-Chain operation"),(0,r.kt)("h5",{id:"size-10"},"Size"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Chunks"),(0,r.kt)("th",{parentName:"tr",align:null},"Significant bytes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},"16")))),(0,r.kt)("h5",{id:"structure-10"},"Structure"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TxType"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"transaction type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"OfferId"),(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},"nft offer id")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"gas fee account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAssetId"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"gas fee asset id")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAssetAmount"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"packed fee amount")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func ConvertTxToCancelOfferPubData(oTx *tx.Tx) (pubData []byte, err error) {\n    if oTx.TxType != commonTx.TxTypeCancelOffer {\n        logx.Errorf("[ConvertTxToCancelOfferPubData] invalid tx type")\n        return nil, errors.New("[ConvertTxToCancelOfferPubData] invalid tx type")\n    }\n    // parse tx\n    txInfo, err := commonTx.ParseCancelOfferTxInfo(oTx.TxInfo)\n    if err != nil {\n        logx.Errorf("[ConvertTxToCancelOfferPubData] unable to parse tx info: %s", err.Error())\n        return nil, err\n    }\n    var buf bytes.Buffer\n    buf.WriteByte(uint8(oTx.TxType))\n    buf.Write(Uint32ToBytes(uint32(txInfo.AccountIndex)))\n    buf.Write(Uint24ToBytes(txInfo.OfferId))\n    buf.Write(Uint32ToBytes(uint32(txInfo.GasAccountIndex)))\n    buf.Write(Uint16ToBytes(uint16(txInfo.GasFeeAssetId)))\n    packedFeeBytes, err := FeeToPackedFeeBytes(txInfo.GasFeeAssetAmount)\n    if err != nil {\n        logx.Errorf("[ConvertTxToDepositPubData] unable to convert amount to packed fee amount: %s", err.Error())\n        return nil, err\n    }\n    buf.Write(packedFeeBytes)\n    chunk := SuffixPaddingBufToChunkSize(buf.Bytes())\n    buf.Reset()\n    buf.Write(chunk)\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    return buf.Bytes(), nil\n}\n')),(0,r.kt)("h4",{id:"user-transaction-10"},"User transaction"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type CancelOfferTxInfo struct {\n    AccountIndex      int64\n    OfferId           int64\n    GasAccountIndex   int64\n    GasFeeAssetId     int64\n    GasFeeAssetAmount *big.Int\n    ExpiredAt         int64\n    Nonce             int64\n    Sig               []byte\n}\n")),(0,r.kt)("h4",{id:"circuit-9"},"Circuit"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func VerifyCancelOfferTx(\n    api API, flag Variable,\n    tx *CancelOfferTxConstraints,\n    accountsBefore [NbAccountsPerTx]AccountConstraints,\n) (pubData [PubDataSizePerTx]Variable) {\n    pubData = CollectPubDataFromCancelOffer(api, *tx)\n    // verify params\n    IsVariableEqual(api, flag, tx.AccountIndex, accountsBefore[0].AccountIndex)\n    IsVariableEqual(api, flag, tx.GasAccountIndex, accountsBefore[1].AccountIndex)\n    IsVariableEqual(api, flag, tx.GasFeeAssetId, accountsBefore[0].AssetsInfo[0].AssetId)\n    IsVariableEqual(api, flag, tx.GasFeeAssetId, accountsBefore[1].AssetsInfo[0].AssetId)\n    offerIdBits := api.ToBinary(tx.OfferId, 24)\n    assetId := api.FromBinary(offerIdBits[7:]...)\n    IsVariableEqual(api, flag, assetId, accountsBefore[0].AssetsInfo[1].AssetId)\n    // should have enough balance\n    tx.GasFeeAssetAmount = UnpackFee(api, tx.GasFeeAssetAmount)\n    IsVariableLessOrEqual(api, flag, tx.GasFeeAssetAmount, accountsBefore[0].AssetsInfo[1].Balance)\n    return pubData\n}\n")),(0,r.kt)("h3",{id:"withdrawnft"},"WithdrawNft"),(0,r.kt)("h4",{id:"description-11"},"Description"),(0,r.kt)("p",null,"This is a layer-2 transaction and is used for withdrawing nft from the layer-2 to the layer-1."),(0,r.kt)("h4",{id:"on-chain-operation-11"},"On-Chain operation"),(0,r.kt)("h5",{id:"size-11"},"Size"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Chunks"),(0,r.kt)("th",{parentName:"tr",align:null},"Significant bytes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},"162")))),(0,r.kt)("h5",{id:"structure-11"},"Structure"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TxType"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"transaction type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CreatorAccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"creator account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CreatorTreasuryRate"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"creator treasury rate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NftIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"unique nft index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CollectionId"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"collection id")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NftL1Address"),(0,r.kt)("td",{parentName:"tr",align:null},"20"),(0,r.kt)("td",{parentName:"tr",align:null},"nft layer-1 address")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ToAddress"),(0,r.kt)("td",{parentName:"tr",align:null},"20"),(0,r.kt)("td",{parentName:"tr",align:null},"receiver address")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"gas fee account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAssetId"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"gas fee asset id")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GasFeeAssetAmount"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"packed fee amount")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NftContentHash"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"nft content hash")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NftL1TokenId"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"nft layer-1 token id")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CreatorAccountNameHash"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"creator account name hash")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func ConvertTxToWithdrawNftPubData(oTx *tx.Tx) (pubData []byte, err error) {\n    if oTx.TxType != commonTx.TxTypeWithdrawNft {\n        logx.Errorf("[ConvertTxToWithdrawNftPubData] invalid tx type")\n        return nil, errors.New("[ConvertTxToWithdrawNftPubData] invalid tx type")\n    }\n    // parse tx\n    txInfo, err := commonTx.ParseWithdrawNftTxInfo(oTx.TxInfo)\n    if err != nil {\n        logx.Errorf("[ConvertTxToWithdrawNftPubData] unable to parse tx info: %s", err.Error())\n        return nil, err\n    }\n    var buf bytes.Buffer\n    buf.WriteByte(uint8(oTx.TxType))\n    buf.Write(Uint32ToBytes(uint32(txInfo.AccountIndex)))\n    buf.Write(Uint32ToBytes(uint32(txInfo.CreatorAccountIndex)))\n    buf.Write(Uint16ToBytes(uint16(txInfo.CreatorTreasuryRate)))\n    buf.Write(Uint40ToBytes(txInfo.NftIndex))\n    buf.Write(Uint16ToBytes(uint16(txInfo.CollectionId)))\n    chunk1 := SuffixPaddingBufToChunkSize(buf.Bytes())\n    buf.Reset()\n    buf.Write(AddressStrToBytes(txInfo.NftL1Address))\n    chunk2 := PrefixPaddingBufToChunkSize(buf.Bytes())\n    buf.Reset()\n    buf.Write(AddressStrToBytes(txInfo.ToAddress))\n    buf.Write(Uint32ToBytes(uint32(txInfo.GasAccountIndex)))\n    buf.Write(Uint16ToBytes(uint16(txInfo.GasFeeAssetId)))\n    packedFeeBytes, err := FeeToPackedFeeBytes(txInfo.GasFeeAssetAmount)\n    if err != nil {\n        logx.Errorf("[ConvertTxToDepositPubData] unable to convert amount to packed fee amount: %s", err.Error())\n        return nil, err\n    }\n    buf.Write(packedFeeBytes)\n    chunk3 := PrefixPaddingBufToChunkSize(buf.Bytes())\n    buf.Reset()\n    buf.Write(chunk1)\n    buf.Write(chunk2)\n    buf.Write(chunk3)\n    buf.Write(PrefixPaddingBufToChunkSize(txInfo.NftContentHash))\n    buf.Write(Uint256ToBytes(txInfo.NftL1TokenId))\n    buf.Write(PrefixPaddingBufToChunkSize(txInfo.CreatorAccountNameHash))\n    return buf.Bytes(), nil\n}\n')),(0,r.kt)("h4",{id:"user-transaction-11"},"User transaction"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type WithdrawNftTxInfo struct {\n    AccountIndex           int64\n    CreatorAccountIndex    int64\n    CreatorAccountNameHash []byte\n    CreatorTreasuryRate    int64\n    NftIndex               int64\n    NftContentHash         []byte\n    NftL1Address           string\n    NftL1TokenId           *big.Int\n    CollectionId           int64\n    ToAddress              string\n    GasAccountIndex        int64\n    GasFeeAssetId          int64\n    GasFeeAssetAmount      *big.Int\n    ExpiredAt              int64\n    Nonce                  int64\n    Sig                    []byte\n}\n")),(0,r.kt)("h4",{id:"circuit-10"},"Circuit"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func VerifyWithdrawNftTx(\n    api API,\n    flag Variable,\n    tx *WithdrawNftTxConstraints,\n    accountsBefore [NbAccountsPerTx]AccountConstraints,\n    nftBefore NftConstraints,\n) (pubData [PubDataSizePerTx]Variable) {\n    pubData = CollectPubDataFromWithdrawNft(api, *tx)\n    // verify params\n    // account index\n    IsVariableEqual(api, flag, tx.AccountIndex, accountsBefore[0].AccountIndex)\n    IsVariableEqual(api, flag, tx.CreatorAccountIndex, accountsBefore[1].AccountIndex)\n    IsVariableEqual(api, flag, tx.GasAccountIndex, accountsBefore[2].AccountIndex)\n    // account name hash\n    IsVariableEqual(api, flag, tx.CreatorAccountNameHash, accountsBefore[1].AccountNameHash)\n    // collection id\n    IsVariableEqual(api, flag, tx.CollectionId, nftBefore.CollectionId)\n    // asset id\n    IsVariableEqual(api, flag, tx.GasFeeAssetId, accountsBefore[0].AssetsInfo[0].AssetId)\n    IsVariableEqual(api, flag, tx.GasFeeAssetId, accountsBefore[2].AssetsInfo[0].AssetId)\n    // nft info\n    IsVariableEqual(api, flag, tx.NftIndex, nftBefore.NftIndex)\n    IsVariableEqual(api, flag, tx.CreatorAccountIndex, nftBefore.CreatorAccountIndex)\n    IsVariableEqual(api, flag, tx.CreatorTreasuryRate, nftBefore.CreatorTreasuryRate)\n    IsVariableEqual(api, flag, tx.AccountIndex, nftBefore.OwnerAccountIndex)\n    IsVariableEqual(api, flag, tx.NftContentHash, nftBefore.NftContentHash)\n    IsVariableEqual(api, flag, tx.NftL1TokenId, nftBefore.NftL1TokenId)\n    IsVariableEqual(api, flag, tx.NftL1Address, nftBefore.NftL1Address)\n    // have enough assets\n    tx.GasFeeAssetAmount = UnpackFee(api, tx.GasFeeAssetAmount)\n    IsVariableLessOrEqual(api, flag, tx.GasFeeAssetAmount, accountsBefore[0].AssetsInfo[0].Balance)\n    return pubData\n}\n")),(0,r.kt)("h3",{id:"fullexit"},"FullExit"),(0,r.kt)("h4",{id:"description-12"},"Description"),(0,r.kt)("p",null,"This is a layer-1 transaction and is used for full exit assets from the layer-2 to the layer-1."),(0,r.kt)("h4",{id:"on-chain-operation-12"},"On-Chain operation"),(0,r.kt)("h5",{id:"size-12"},"Size"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Chunks"),(0,r.kt)("th",{parentName:"tr",align:null},"Significant bytes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},"55")))),(0,r.kt)("h5",{id:"structure-12"},"Structure"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TxType"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"transaction type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"from account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AssetId"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"asset index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AssetAmount"),(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null},"state amount")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountNameHash"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"account name hash")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func ConvertTxToFullExitPubData(oTx *tx.Tx) (pubData []byte, err error) {\n    if oTx.TxType != commonTx.TxTypeFullExit {\n        logx.Errorf("[ConvertTxToFullExitPubData] invalid tx type")\n        return nil, errors.New("[ConvertTxToFullExitPubData] invalid tx type")\n    }\n    // parse tx\n    txInfo, err := commonTx.ParseFullExitTxInfo(oTx.TxInfo)\n    if err != nil {\n        logx.Errorf("[ConvertTxToFullExitPubData] unable to parse tx info: %s", err.Error())\n        return nil, err\n    }\n    var buf bytes.Buffer\n    buf.WriteByte(uint8(oTx.TxType))\n    buf.Write(Uint32ToBytes(uint32(txInfo.AccountIndex)))\n    buf.Write(Uint16ToBytes(uint16(txInfo.AssetId)))\n    buf.Write(Uint128ToBytes(txInfo.AssetAmount))\n    chunk := SuffixPaddingBufToChunkSize(buf.Bytes())\n    buf.Reset()\n    buf.Write(chunk)\n    buf.Write(PrefixPaddingBufToChunkSize(txInfo.AccountNameHash))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    buf.Write(PrefixPaddingBufToChunkSize([]byte{}))\n    return buf.Bytes(), nil\n}\n')),(0,r.kt)("h4",{id:"user-transaction-12"},"User transaction"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountNameHash"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"account name hash")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AssetAddress"),(0,r.kt)("td",{parentName:"tr",align:null},"20"),(0,r.kt)("td",{parentName:"tr",align:null},"asset layer-1 address")))),(0,r.kt)("h4",{id:"circuit-11"},"Circuit"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func VerifyFullExitTx(\n    api API, flag Variable,\n    tx FullExitTxConstraints,\n    accountsBefore [NbAccountsPerTx]AccountConstraints,\n) (pubData [PubDataSizePerTx]Variable) {\n    pubData = CollectPubDataFromFullExit(api, tx)\n    // verify params\n    IsVariableEqual(api, flag, tx.AccountNameHash, accountsBefore[0].AccountNameHash)\n    IsVariableEqual(api, flag, tx.AccountIndex, accountsBefore[0].AccountIndex)\n    IsVariableEqual(api, flag, tx.AssetId, accountsBefore[0].AssetsInfo[0].AssetId)\n    IsVariableEqual(api, flag, tx.AssetAmount, accountsBefore[0].AssetsInfo[0].Balance)\n    return pubData\n}\n")),(0,r.kt)("h3",{id:"fullexitnft"},"FullExitNft"),(0,r.kt)("h4",{id:"description-13"},"Description"),(0,r.kt)("p",null,"This is a layer-1 transaction and is used for full exit NFTs from the layer-2 to the layer-1."),(0,r.kt)("h4",{id:"on-chain-operation-13"},"On-Chain operation"),(0,r.kt)("h5",{id:"size-13"},"Size"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Chunks"),(0,r.kt)("th",{parentName:"tr",align:null},"Significant bytes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},"164")))),(0,r.kt)("h5",{id:"structure-13"},"Structure"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TxType"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"transaction type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"from account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CreatorAccountIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"creator account index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CreatorTreasuryRate"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"creator treasury rate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NftIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"unique nft index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CollectionId"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"collection id")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NftL1Address"),(0,r.kt)("td",{parentName:"tr",align:null},"20"),(0,r.kt)("td",{parentName:"tr",align:null},"nft layer-1 address")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountNameHash"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"account name hash")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CreatorAccountNameHash"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"creator account name hash")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NftContentHash"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"nft content hash")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NftL1TokenId"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"nft layer-1 token id")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func ConvertTxToFullExitNftPubData(oTx *tx.Tx) (pubData []byte, err error) {\n    if oTx.TxType != commonTx.TxTypeFullExitNft {\n        logx.Errorf("[ConvertTxToFullExitNftPubData] invalid tx type")\n        return nil, errors.New("[ConvertTxToFullExitNftPubData] invalid tx type")\n    }\n    // parse tx\n    txInfo, err := commonTx.ParseFullExitNftTxInfo(oTx.TxInfo)\n    if err != nil {\n        logx.Errorf("[ConvertTxToFullExitNftPubData] unable to parse tx info: %s", err.Error())\n        return nil, err\n    }\n    var buf bytes.Buffer\n    buf.WriteByte(uint8(oTx.TxType))\n    buf.Write(Uint32ToBytes(uint32(txInfo.AccountIndex)))\n    buf.Write(Uint32ToBytes(uint32(txInfo.CreatorAccountIndex)))\n    buf.Write(Uint16ToBytes(uint16(txInfo.CreatorTreasuryRate)))\n    buf.Write(Uint40ToBytes(txInfo.NftIndex))\n    buf.Write(Uint16ToBytes(uint16(txInfo.CollectionId)))\n    chunk1 := SuffixPaddingBufToChunkSize(buf.Bytes())\n    buf.Reset()\n    buf.Write(AddressStrToBytes(txInfo.NftL1Address))\n    chunk2 := PrefixPaddingBufToChunkSize(buf.Bytes())\n    buf.Reset()\n    buf.Write(chunk1)\n    buf.Write(chunk2)\n    buf.Write(PrefixPaddingBufToChunkSize(txInfo.AccountNameHash))\n    buf.Write(PrefixPaddingBufToChunkSize(txInfo.CreatorAccountNameHash))\n    buf.Write(PrefixPaddingBufToChunkSize(txInfo.NftContentHash))\n    buf.Write(Uint256ToBytes(txInfo.NftL1TokenId))\n    return buf.Bytes(), nil\n}\n')),(0,r.kt)("h4",{id:"user-transaction-13"},"User transaction"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(byte)"),(0,r.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AccountNameHash"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"account name hash")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NftIndex"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"unique nft index")))),(0,r.kt)("h4",{id:"circuit-12"},"Circuit"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func VerifyFullExitNftTx(\n    api API, flag Variable,\n    tx FullExitNftTxConstraints,\n    accountsBefore [NbAccountsPerTx]AccountConstraints, nftBefore NftConstraints,\n) (pubData [PubDataSizePerTx]Variable) {\n    pubData = CollectPubDataFromFullExitNft(api, tx)\n    // verify params\n    IsVariableEqual(api, flag, tx.AccountNameHash, accountsBefore[0].AccountNameHash)\n    IsVariableEqual(api, flag, tx.AccountIndex, accountsBefore[0].AccountIndex)\n    IsVariableEqual(api, flag, tx.NftIndex, nftBefore.NftIndex)\n    isCheck := api.IsZero(api.IsZero(tx.CreatorAccountNameHash))\n    isCheck = api.And(flag, isCheck)\n    IsVariableEqual(api, isCheck, tx.CreatorAccountIndex, accountsBefore[1].AccountIndex)\n    IsVariableEqual(api, isCheck, tx.CreatorAccountNameHash, accountsBefore[1].AccountNameHash)\n    IsVariableEqual(api, flag, tx.CreatorAccountIndex, nftBefore.CreatorAccountIndex)\n    IsVariableEqual(api, flag, tx.CreatorTreasuryRate, nftBefore.CreatorTreasuryRate)\n    isOwner := api.And(api.IsZero(api.Sub(tx.AccountIndex, nftBefore.OwnerAccountIndex)), flag)\n    IsVariableEqual(api, isOwner, tx.NftContentHash, nftBefore.NftContentHash)\n    IsVariableEqual(api, isOwner, tx.NftL1Address, nftBefore.NftL1Address)\n    IsVariableEqual(api, isOwner, tx.NftL1TokenId, nftBefore.NftL1TokenId)\n    tx.NftContentHash = api.Select(isOwner, tx.NftContentHash, 0)\n    tx.NftL1Address = api.Select(isOwner, tx.NftL1Address, 0)\n    tx.NftL1TokenId = api.Select(isOwner, tx.NftL1TokenId, 0)\n    return pubData\n}\n")),(0,r.kt)("h2",{id:"smart-contracts-api"},"Smart contracts API"),(0,r.kt)("h3",{id:"rollup-contract"},"Rollup contract"),(0,r.kt)("h4",{id:"registerzns-1"},"RegisterZNS"),(0,r.kt)("p",null,"Register an ZNS account which is an ENS like domain for layer-1 and a short account name for your layer-2 account."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function registerZNS(string calldata _name, address _owner, bytes32 _zkbnbPubKeyX, bytes32 _zkbnbPubKeyY) external payable nonReentrant\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_name"),": your favor account name"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_owner"),": account name layer-1 owner address"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_zkbnbPubKeyX"),": zkBNB layer-2 public key X"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_zkbnbPubKeyY"),": zkBNB layer-2 public key Y")),(0,r.kt)("h4",{id:"deposit-bnb"},"Deposit BNB"),(0,r.kt)("p",null,"Deposit BNB to Rollup - transfer BNB from user L1 address into Rollup account"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function depositBNB(bytes32 _accountNameHash) external payable\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_accountNameHash"),": The layer-2")),(0,r.kt)("h4",{id:"deposit-bep20"},"Deposit BEP20"),(0,r.kt)("p",null,"Deposit BEP20 assets to Rollup - transfer BEP20 assets from user L1 address into Rollup account"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function depositBEP20(\n    IERC20 _token,\n    uint104 _amount,\n    bytes32 _accountNameHash\n) external nonReentrant\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_token"),": valid BEP20 address"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_amount"),": deposit amount"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_accountNameHash"),": ZNS account name hash")),(0,r.kt)("h4",{id:"withdraw-pending-bnbbep20"},"Withdraw Pending BNB/BEP20"),(0,r.kt)("p",null,"Withdraw BNB/BEP20 token to L1 - Transfer token from contract to owner"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function withdrawPendingBalance(\n    address payable _owner,\n    address _token,\n    uint128 _amount\n) external nonReentrant\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_owner"),": layer-1 address"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_token"),": asset address, ",(0,r.kt)("inlineCode",{parentName:"li"},"0")," for BNB"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_amount"),": withdraw amount")),(0,r.kt)("h4",{id:"withdraw-pending-nft"},"Withdraw Pending Nft"),(0,r.kt)("p",null,"Withdraw NFT to L1"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function withdrawPendingNFTBalance(uint40 _nftIndex) external\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_nftIndex"),": nft index")),(0,r.kt)("h4",{id:"censorship-resistance"},"Censorship resistance"),(0,r.kt)("p",null,"Register full exit request to withdraw all token balance from the account. The user needs to call it if she believes that her transactions are censored by the validator."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function requestFullExit(bytes32 _accountNameHash, address _asset) public nonReentrant\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_accountNameHash"),": ZNS account name hash"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_asset"),": BEP20 asset address, ",(0,r.kt)("inlineCode",{parentName:"li"},"0")," for BNB")),(0,r.kt)("p",null,"Register full exit request to withdraw NFT tokens balance from the account. Users need to call it if they believe that their transactions are censored by the validator."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function requestFullExitNFT(bytes32 _accountNameHash, uint32 _nftIndex) public nonReentrant\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_accountNameHash"),": ZNS account name hash"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_nftIndex"),": nft index")),(0,r.kt)("h4",{id:"desert-mode"},"Desert mode"),(0,r.kt)("h5",{id:"withdraw-funds"},"Withdraw funds"),(0,r.kt)("p",null,"Withdraws token from Rollup to L1 in case of desert mode. User must provide proof that she owns funds."),(0,r.kt)("p",null,"// TODO"),(0,r.kt)("h4",{id:"rollup-operations"},"Rollup Operations"),(0,r.kt)("h5",{id:"commit-block"},"Commit block"),(0,r.kt)("p",null,"Submit committed block data. Only active validator can make it. On-chain operations will be checked on contract and fulfilled on block verification."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"struct StoredBlockInfo {\n    uint32 blockNumber;\n    uint64 priorityOperations;\n    bytes32 pendingOnchainOperationsHash;\n    uint256 timestamp;\n    bytes32 stateRoot;\n    bytes32 commitment;\n}\n\nstruct CommitBlockInfo {\n    bytes32 newStateRoot;\n    bytes publicData;\n    uint256 timestamp;\n    uint32[] publicDataOffsets;\n    uint32 blockNumber;\n}\n\nfunction commitBlocks(\n    StoredBlockInfo memory _lastCommittedBlockData,\n    CommitBlockInfo[] memory _newBlocksData\n)\nexternal\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"StoredBlockInfo"),": block data that we store on BNB Smart Chain. We store hash of this structure in storage and pass it in tx arguments every time we need to access any of its field."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"blockNumber"),": rollup block number"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"priorityOperations"),": priority operations count"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pendingOnchainOperationsHash"),": hash of all on-chain operations that have to be processed when block is finalized (verified)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"timestamp"),": block timestamp"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"stateRoot"),": root hash of the rollup tree state"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"commitment"),": rollup block commitment")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"CommitBlockInfo"),": data needed for new block commit"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"newStateRoot"),": new layer-2 root hash"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"publicData"),": public data of the executed rollup operations"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"timestamp"),": block timestamp"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"publicDataOffsets"),": list of on-chain operations offset"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"blockNumber"),": rollup block number")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"commitBlocks")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"commitOneBlock")," are used for committing layer-2 transactions data on-chain."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_lastCommittedBlockData"),": last committed block header"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_newBlocksData"),": pending commit blocks")),(0,r.kt)("h5",{id:"verify-and-execute-blocks"},"Verify and execute blocks"),(0,r.kt)("p",null,"Submit proofs of blocks and make it verified on-chain. Only active validator can make it. This block on-chain operations will be fulfilled."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"struct VerifyAndExecuteBlockInfo {\n    StoredBlockInfo blockHeader;\n    bytes[] pendingOnchainOpsPubData;\n}\n\nfunction verifyAndExecuteBlocks(VerifyAndExecuteBlockInfo[] memory _blocks, uint256[] memory _proofs) external\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"VerifyAndExecuteBlockInfo"),": block data that is used for verifying blocks"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"blockHeader"),": related block header"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pendingOnchainOpsPubdata"),": public data of pending on-chain operations")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"verifyBlocks"),": is used for verifying block data and proofs"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_blocks"),": pending verify blocks"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_proofs"),": Groth16 proofs")),(0,r.kt)("h4",{id:"desert-mode-trigger"},"Desert mode trigger"),(0,r.kt)("p",null,"Checks if Desert mode must be entered. Desert mode must be entered in case of current BNB Smart Chain block number is higher than the oldest of existed priority requests expiration block number."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function activateDesertMode() public returns (bool)\n")),(0,r.kt)("h4",{id:"revert-blocks"},"Revert blocks"),(0,r.kt)("p",null,"Revert blocks that were not verified before deadline determined by ",(0,r.kt)("inlineCode",{parentName:"p"},"EXPECT_VERIFICATION_IN")," constant."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function revertBlocks(StoredBlockInfo[] memory _blocksToRevert) external\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_blocksToRevert"),": committed blocks to revert in reverse order starting from last committed.")),(0,r.kt)("h4",{id:"set-default-nft-factory"},"Set default NFT factory"),(0,r.kt)("p",null,"Set default NFT factory, which will be used for withdrawing NFT by default"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function setDefaultNFTFactory(NFTFactory _factory) external\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_factory"),": NFT factory address")),(0,r.kt)("h4",{id:"register-nft-factory"},"Register NFT factory"),(0,r.kt)("p",null,"Register NFT factory, which will be used for withdrawing NFT."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function registerNFTFactory(\n    string calldata _creatorAccountName,\n    uint32 _collectionId,\n    NFTFactory _factory\n) external\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_creatorAccountName"),": NFT creator account name"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_collectionId"),": Collection id in the layer-2"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_factory"),": Address of NFTFactory")),(0,r.kt)("h4",{id:"get-nft-factory-for-creator"},"Get NFT factory for creator"),(0,r.kt)("p",null,"Get NFT factory which will be used for withdrawing NFT for corresponding creator"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function getNFTFactory(bytes32 _creatorAccountNameHash, uint32 _collectionId) public view returns (address)\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_creatorAccountNameHash"),": Creator account name hash"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_collectionId"),": Collection id")),(0,r.kt)("h3",{id:"governance-contract"},"Governance contract"),(0,r.kt)("h4",{id:"change-governor"},"Change governor"),(0,r.kt)("p",null,"Change current governor. The caller must be current governor."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"function changeGovernor(address _newGovernor)\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_newGovernor"),": Address of the new governor")),(0,r.kt)("h4",{id:"add-asset"},"Add asset"),(0,r.kt)("p",null,"Add asset to the list of networks assets. The caller must be current asset governance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function addAsset(address _asset) external\n")),(0,r.kt)("h4",{id:"set-asset-paused"},"Set asset paused"),(0,r.kt)("p",null,"Set asset status as paused or active. The caller must be current governor. It is impossible to create deposits of the paused assets."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function setAssetPaused(address _assetAddress, bool _assetPaused) external\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_assetAddress"),": asset layer-1 address"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_assetPausesd"),": status")),(0,r.kt)("h4",{id:"set-validator"},"Set validator"),(0,r.kt)("p",null,"Change validator status (active or not active). The caller must be current governor."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function setValidator(address _validator, bool _active)\n")),(0,r.kt)("h5",{id:"change-asset-governance"},"Change asset governance"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function changeAssetGovernance(AssetGovernance _newAssetGovernance) external\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_newAssetGovernance"),": New asset Governance")),(0,r.kt)("h4",{id:"check-for-governor"},"Check for governor"),(0,r.kt)("p",null,"Validate that specified address is the token governance address"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function requireGovernor(address _address)\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_address"),": Address to check")),(0,r.kt)("h4",{id:"check-for-active-validator"},"Check for active validator"),(0,r.kt)("p",null,"Validate that specified address is the active validator"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function requireActiveValidator(address _address)\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_address"),": Address to check")),(0,r.kt)("h4",{id:"check-that-asset-address-is-valid"},"Check that asset address is valid"),(0,r.kt)("p",null,"Validate asset address (it must be presented in assets list)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function validateAssetAddress(address _assetAddr) external view returns (uint16)\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_assetAddr"),": Asset address")),(0,r.kt)("p",null,"Returns: asset id."),(0,r.kt)("h3",{id:"asset-governance-contract"},"Asset Governance contract"),(0,r.kt)("h4",{id:"add-asset-1"},"Add asset"),(0,r.kt)("p",null,"Collecting fees for adding an asset and passing the call to the ",(0,r.kt)("inlineCode",{parentName:"p"},"addAsset")," function in the governance contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function addAsset(address _assetAddress) external\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_assetAddress"),": BEP20 asset address")),(0,r.kt)("h4",{id:"set-listing-fee-asset"},"Set listing fee asset"),(0,r.kt)("p",null,"Set new listing asset and fee, can be called only by governor."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function setListingFeeAsset(IERC20 _newListingFeeAsset, uint256 _newListingFee) external\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_newListingFeeAsset"),": address of the asset in which fees will be collected"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_newListingFee"),": amount of tokens that will need to be paid for adding tokens")),(0,r.kt)("h4",{id:"set-listing-fee"},"Set listing fee"),(0,r.kt)("p",null,"Set new listing fee, can be called only by governor."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function setListingFee(uint256 _newListingFee)\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_newListingFee"),": amount of assets that will need to be paid for adding tokens")),(0,r.kt)("h4",{id:"set-lister"},"Set lister"),(0,r.kt)("p",null,"Enable or disable asset lister, if enabled new assets can be added by that address without payment, can be called only by governor."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function setLister(address _listerAddress, bool _active)\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_listerAddress"),": address that can list tokens without fee"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_active"),": active flag")),(0,r.kt)("h4",{id:"set-listing-cap"},"Set listing cap"),(0,r.kt)("p",null,"Change maximum amount of assets that can be listed using this method, can be called only by governor."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function setListingCap(uint16 _newListingCap)\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_newListingCap"),": max number of assets that can be listed using this contract")),(0,r.kt)("h4",{id:"set-treasury"},"Set treasury"),(0,r.kt)("p",null,"Change address that collects payments for listing assets, can be called only by governor."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function setTreasury(address _newTreasury)\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_newTreasury"),": address that collects listing payments")))}c.isMDXComponent=!0}}]);