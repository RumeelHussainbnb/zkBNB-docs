"use strict";(self.webpackChunkzkbnb_docs=self.webpackChunkzkbnb_docs||[]).push([[322],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>p});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var o=r.createContext({}),c=function(e){var t=r.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return r.createElement(o.Provider,{value:t},e.children)},u="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},g=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(n),g=a,p=u["".concat(o,".").concat(g)]||u[g]||f[g]||l;return n?r.createElement(p,i(i({ref:t},d),{},{components:n})):r.createElement(p,i({ref:t},d))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,i=new Array(l);i[0]=g;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[u]="string"==typeof e?e:a,i[1]=s;for(var c=2;c<l;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}g.displayName="MDXCreateElement"},23417:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>y,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var r=n(87462),a=(n(67294),n(3905)),l=n(25108);const i={title:"zkBNB Go SDK"},s="Quickstart",o={unversionedId:"sdks/zkbnb-go-sdk/quickstart",id:"sdks/zkbnb-go-sdk/quickstart",title:"zkBNB Go SDK",description:"zkBNB Go SDK provides API for interacting with zkBNB L2 component in the node environment.",source:"@site/docs/sdks/zkbnb-go-sdk/quickstart.md",sourceDirName:"sdks/zkbnb-go-sdk",slug:"/sdks/zkbnb-go-sdk/quickstart",permalink:"/zkBNB-docs/docs/sdks/zkbnb-go-sdk/quickstart",draft:!1,editUrl:"https://github.com/RumeelHussainbnb/zkBNB-docs/docs/sdks/zkbnb-go-sdk/quickstart.md",tags:[],version:"current",frontMatter:{title:"zkBNB Go SDK"},sidebar:"sdkSidebar",previous:{title:"\ud83e\uddee zkBNB SDKs",permalink:"/zkBNB-docs/docs/zkbnb-sdk-guides"},next:{title:"zkBNB Javascript SDK",permalink:"/zkBNB-docs/docs/sdks/zkbnb-js-sdk/quickstart"}},c={},d=[{value:"Overview",id:"overview",level:2},{value:"Usage",id:"usage",level:2},{value:"Installation",id:"installation",level:3},{value:"zkBNB Client",id:"zkbnb-client",level:2},{value:"Init sdk",id:"init-sdk",level:3},{value:"Queries",id:"queries",level:3},{value:"Get Protocol Rate",id:"get-protocol-rate",level:4},{value:"Get Layer2 Basic Info",id:"get-layer2-basic-info",level:4},{value:"Get Current Height",id:"get-current-height",level:4},{value:"Get Gas Account",id:"get-gas-account",level:4},{value:"Common",id:"common",level:3},{value:"Get Rollbacks",id:"get-rollbacks",level:4},{value:"Get Block By Commitment",id:"get-block-by-commitment",level:4},{value:"Get Gas Fee Assets",id:"get-gas-fee-assets",level:4},{value:"Get Gas Fee",id:"get-gas-fee",level:4},{value:"Get Next Nonce",id:"get-next-nonce",level:4},{value:"Get Max OfferId",id:"get-max-offerid",level:4},{value:"Get Block By Height",id:"get-block-by-height",level:4},{value:"Get Blocks",id:"get-blocks",level:4},{value:"Get Transactions By AccountIndex",id:"get-transactions-by-accountindex",level:4},{value:"Get Txs By BlockHeight",id:"get-txs-by-blockheight",level:4},{value:"Get Transactions",id:"get-transactions",level:4},{value:"Get Transaction",id:"get-transaction",level:4},{value:"Get Txs By L1Address",id:"get-txs-by-l1address",level:4},{value:"Get Pending Transactions",id:"get-pending-transactions",level:4},{value:"Get Pending Transactions",id:"get-pending-transactions-1",level:4},{value:"Get Executed Transactions",id:"get-executed-transactions",level:4},{value:"Account",id:"account",level:3},{value:"Get Accounts",id:"get-accounts",level:4},{value:"Get  AccountBy L1Address",id:"get--accountby-l1address",level:4},{value:"Change PubKey",id:"change-pubkey",level:4},{value:"Asset",id:"asset",level:3},{value:"Get Asset",id:"get-asset",level:4},{value:"Get Asset By Id",id:"get-asset-by-id",level:3},{value:"Get Assets",id:"get-assets",level:3},{value:"Transfer Asset",id:"transfer-asset",level:4},{value:"Withdrawal Asset",id:"withdrawal-asset",level:4},{value:"NFT",id:"nft",level:3},{value:"Create Collection",id:"create-collection",level:4},{value:"Get Max CollectionId",id:"get-max-collectionid",level:4},{value:"Mint NFT",id:"mint-nft",level:4},{value:"Get Nft Next Nonce",id:"get-nft-next-nonce",level:4},{value:"Get Nft By TxHash",id:"get-nft-by-txhash",level:4},{value:"GetNftByNftIndex",id:"getnftbynftindex",level:4},{value:"Get NFTs By Account Index",id:"get-nfts-by-account-index",level:4},{value:"Update Nft By Index",id:"update-nft-by-index",level:4},{value:"Withdraw NFT",id:"withdraw-nft",level:4},{value:"Cancel Offer",id:"cancel-offer",level:4},{value:"Transfer Nft",id:"transfer-nft",level:4},{value:"Atomic Match",id:"atomic-match",level:4},{value:"zkBNB L1 Client",id:"zkbnb-l1-client",level:2},{value:"Interface",id:"interface",level:3},{value:"Init",id:"init",level:3},{value:"Send tx",id:"send-tx",level:3},{value:"Register ZNS",id:"register-zns",level:3},{value:"Deposit BNB",id:"deposit-bnb",level:3},{value:"Deposit BEP20",id:"deposit-bep20",level:3},{value:"Full Exit Token",id:"full-exit-token",level:3},{value:"Full Exit Token",id:"full-exit-token-1",level:3},{value:"Deposit NFT",id:"deposit-nft",level:3},{value:"Full Exit NFT",id:"full-exit-nft",level:3}],u=e=>function(t){return l.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",t)},f=u("Tabs"),g=u("TabItem"),p={toc:d};function y(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"quickstart"},"Quickstart"),(0,a.kt)("p",null,"zkBNB Go SDK provides API for interacting with zkBNB L2 component in the node environment."),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("admonition",{type:"danger"},(0,a.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,a.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Go SDK Interface is unstable")),(0,a.kt)("p",{parentName:"admonition"},"The Go SDK hasn't hit v1.0 yet. Its public interface is unstable, and there are breaking changes scheduled to happen in the coming weeks to its interface.")),(0,a.kt)("p",null,"The zkBNB Go SDK provides a thin wrapper around thin all the apis provided by zkBNB, including a simple key manager for signing\ntxs and sending signed txs to zkBNB."),(0,a.kt)("h2",{id:"usage"},"Usage"),(0,a.kt)("h3",{id:"installation"},"Installation"),(0,a.kt)("p",null,"The supported go versions are 1.18 or above."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"go get github.com/bnb-chain/zkbnb-go-sdk\n")),(0,a.kt)("p",null,"or"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'import (\n    "github.com/bnb-chain/zkbnb-go-sdk" latest\n)\n')),(0,a.kt)("h2",{id:"zkbnb-client"},"zkBNB Client"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"type ZkBNBClient interface {\n    ZkBNBQuerier\n    ZkBNBTxSender\n}\n")),(0,a.kt)("p",null,"The zkBNB go sdk wraps the supported apis and also provides methods to sign txs with the key manager."),(0,a.kt)("h3",{id:"init-sdk"},"Init sdk"),(0,a.kt)("p",null,"The zkBNB client can be initiated by an API endpoint."),(0,a.kt)(f,{mdxType:"Tabs"},(0,a.kt)(g,{value:"privateKey",label:"Create client by privateKey",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'chainNetworkId := 97 // bsc mainnet: 56, bsc testnet: 97\nprivateKey := "your private key"\ntestnetEndpoint := "https://testapi.zkbnbchain.org/" // bsc testnest\n\n// Initialize client with private key\nclient, err := NewZkBNBClientWithPrivateKey(testnetEndpoint, privateKey, chainNetworkId)\n\nif err != nil {\n    fmt.Errorf("error Occurred when Creating ZKBNB client! error:%s", err.Error())\n}\n'))),(0,a.kt)(g,{value:"seed",label:"Create client by seed",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'chainNetworkId := 97 // bsc mainnet: 56, bsc testnet: 97\nprivateKey := "your private key"\nendpoint := "https://testapi.zkbnbchain.org" // bsc testnest: https://testapi.zkbnbchain.org\n\n// Generate seed by private key\nseed, err := accounts.GenerateSeed(privateKey, chainNetworkId)\nif err != nil {\n    return nil\n}\n\nprivateKeyInEcdsa, err := crypto.HexToECDSA(testPrivateKey)\nif err != nil {\n    return\n}\naddress := crypto.PubkeyToAddress(privateKeyInEcdsa.PublicKey)\n\n// Initialize client with seed\nclient, err := NewZkBNBClientNoAuthorized(endpoint, seed, address.Hex(), chainNetworkId)\nif err != nil {\n    fmt.Errorf("error Occurred when Creating ZKBNB client! error:%s", err.Error())\n}\n')))),(0,a.kt)("h3",{id:"queries"},"Queries"),(0,a.kt)("p",null,"You can perform the query methods directly:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"// query the layer2 basic info\nlayer2Info, err := client.GetLayer2BasicInfo()\n")),(0,a.kt)("h4",{id:"get-protocol-rate"},"Get Protocol Rate"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"protocolRate, err := client.GetProtocolRate()\n")),(0,a.kt)("h4",{id:"get-layer2-basic-info"},"Get Layer2 Basic Info"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"basicInfo, err := client.GetLayer2BasicInfo()\n")),(0,a.kt)("h4",{id:"get-current-height"},"Get Current Height"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"height, err := client.GetCurrentHeight()\n")),(0,a.kt)("h4",{id:"get-gas-account"},"Get Gas Account"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"gasAccount, err := client.GetGasAccount()\n")),(0,a.kt)("h3",{id:"common"},"Common"),(0,a.kt)("h4",{id:"get-rollbacks"},"Get Rollbacks"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"total, rollbacks, err := client.GetRollbacks(1, 0, 10)\n")),(0,a.kt)("h4",{id:"get-block-by-commitment"},"Get Block By Commitment"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'block, err := client.GetBlockByCommitment("block commitment")\n')),(0,a.kt)("h4",{id:"get-gas-fee-assets"},"Get Gas Fee Assets"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"gasFeeAssets, err := client.GetGasFeeAssets()\n")),(0,a.kt)("h4",{id:"get-gas-fee"},"Get Gas Fee"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"assetId := 1\ntxType := 1\ngasFee, err := client.GetGasFee(assetId, txType)\n")),(0,a.kt)("h4",{id:"get-next-nonce"},"Get Next Nonce"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"accountIdx := 1\nnonce, err := client.GetNextNonce(accountIdx)\n")),(0,a.kt)("h4",{id:"get-max-offerid"},"Get Max OfferId"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"accountIdx := 1\nmaxOfferId, err := client.GetMaxOfferId(accountIdx)\n")),(0,a.kt)("h4",{id:"get-block-by-height"},"Get Block By Height"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"block, err := client.GetBlockByHeight(1)\n")),(0,a.kt)("h4",{id:"get-blocks"},"Get Blocks"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"total, blocks, err := client.GetBlocks(0, 10)\n")),(0,a.kt)("p",null,"Responses"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "commitment": "a5cfc8e112d3e1195dd803d303a77884ced4d04361e3c7298aef996ba43c1366",\n    "height": 15,\n    "state_root": "0bfbcbffe34f122d7c72914f4458e847bc011027d0100eb0ef3e81c86f292799",\n    "priority_operations": 1,\n    "pending_on_chain_operations_hash": "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470",\n    "pending_on_chain_operations_pub_data": "",\n    "committed_tx_hash": "0x9faf91216d31ab6a6d65098b50e45ba49d05b26ace2d6545701ece7511565afa",\n    "committed_at": 1679740797,\n    "verified_tx_hash": "0xf3a5fc5058d7aab754132b7d542f6736651a8cd924e5fac67447cda4f7b6cf30",\n    "verified_at": 1679740827,\n    "txs": [\n      {\n        "hash": "164026b9b65574834dc020d924bd7496bcf7f1dccedc8f6d3ab7780356343c95",\n        "type": 3,\n        "amount": "0",\n        "info": "{\\"TxType\\":3,\\"L1Address\\":\\"0xa7F23Ad2b0473Bd05012753624eDD77B4CAcdfa3\\",\\"CreatorAccountIndex\\":2,\\"RoyaltyRate\\":0,\\"NftContentType\\":0,\\"NftContentHash\\":\\"+csUG4e6c/jFapGV/oXbLPsbBzU0KWZf13GT48iW7+I=\\",\\"CollectionId\\":0,\\"NftIndex\\":1,\\"AccountIndex\\":2}",\n        "status": 5,\n        "index": 0,\n        "gas_fee_asset_id": -1,\n        "gas_fee": "0",\n        "nft_index": 1,\n        "collection_id": -1,\n        "asset_id": -1,\n        "asset_name": "",\n        "native_address": "0xa7F23Ad2b0473Bd05012753624eDD77B4CAcdfa3",\n        "extra_info": "",\n        "memo": "",\n        "account_index": 2,\n        "l1_address": "0xa7F23Ad2b0473Bd05012753624eDD77B4CAcdfa3",\n        "nonce": -1,\n        "expire_at": 9223372036854775807,\n        "block_height": 15,\n        "created_at": 1679740733,\n        "state_root": "",\n        "to_account_index": -1,\n        "to_l1_address": ""\n      }\n    ],\n    "status": 5,\n    "size": 1\n  }\n]\n')),(0,a.kt)("h4",{id:"get-transactions-by-accountindex"},"Get Transactions By AccountIndex"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"total, txs, err := client.GetTxsByAccountIndex(1, 0, 10)\n")),(0,a.kt)("h4",{id:"get-txs-by-blockheight"},"Get Txs By BlockHeight"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"txs, err := client.GetTxsByBlockHeight(1)\n")),(0,a.kt)("h4",{id:"get-transactions"},"Get Transactions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"total, txs, err := client.GetTxs(0, 10)\n")),(0,a.kt)("p",null,"Responses"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'// txList\n[\n    {\n        "hash": "2a7013dc6e6dfdf6d16d97e54a0f5aa847accb108fc92c1725cf8397f7cbddcd",\n        "type": 6,\n        "amount": "0",\n        "info": "{\\"AccountIndex\\":4,\\"CollectionId\\":0,\\"Name\\":\\"Nft Collection - my collection\\",\\"Introduction\\":\\"Great Nft!\\",\\"GasAccountIndex\\":1,\\"GasFeeAssetId\\":0,\\"GasFeeAssetAmount\\":10000000000000,\\"ExpiredAt\\":1669863880421,\\"Nonce\\":0,\\"Sig\\":\\"feu00A+uH1pceT6Zi4snUIsE09pV7J9DpIgh0D7APwgEsT0cXQJoEI9YkKpyCjUN7ZFQwjhSWYAzsoCM3jdneA==\\"}",\n        "status": 5,\n        "index": 0,\n        "gas_fee_asset_id": 0,\n        "gas_fee": "10000000000000",\n        "nft_index": -1,\n        "collection_id": 0,\n        "asset_id": -1,\n        "asset_name": "",\n        "native_address": "0",\n        "extra_info": "",\n        "memo": "",\n        "account_index": 4,\n        "account_name": "walt.legend",\n        "nonce": 0,\n        "expire_at": 1669863880421,\n        "block_height": 5,\n        "created_at": 1669863340,\n        "state_root": "",\n        "to_account_index": -1,\n        "to_account_name": ""\n    }\n]\n')),(0,a.kt)("h4",{id:"get-transaction"},"Get Transaction"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'tx, err := client.GetTx("tx hash")\n')),(0,a.kt)("h4",{id:"get-txs-by-l1address"},"Get Txs By L1Address"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'total, txs, err := client.GetTxsByL1Address("l1 address", 0, 10)\n')),(0,a.kt)("h4",{id:"get-pending-transactions"},"Get Pending Transactions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"total, txs, err := client.GetPendingTxs(0, 10)\n")),(0,a.kt)("h4",{id:"get-pending-transactions-1"},"Get Pending Transactions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'total, txs, err := client.GetPendingTxsByL1Address("l1 address")\n')),(0,a.kt)("h4",{id:"get-executed-transactions"},"Get Executed Transactions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"total, txs, err := client.GetExecutedTxs(0, 10)\n")),(0,a.kt)("h3",{id:"account"},"Account"),(0,a.kt)("h4",{id:"get-accounts"},"Get Accounts"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"accounts, err := client.GetAccounts(0, 10)\n")),(0,a.kt)("h4",{id:"get--accountby-l1address"},"Get  AccountBy L1Address"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'account, err := client.GetAccountByL1Address("l1 address")\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "status": 1,\n  "index": 3,\n  "l1_address": "0x2fE6e6b5A084fEcd0A5cC109F7d5B5bbE9f0fE54",\n  "name": "",\n  "pk": "3f4f8ef27d0ccabb9654d3003dc289f60e888afe086789e4e230563e529b7824",\n  "nonce": 7,\n  "assets": [\n    {\n      "id": 0,\n      "name": "BNB",\n      "balance": "999920000000000000",\n      "price": "0E+00"\n    }\n  ],\n  "total_asset_value": "0"\n}\n')),(0,a.kt)("h4",{id:"change-pubkey"},"Change PubKey"),(0,a.kt)(f,{mdxType:"Tabs"},(0,a.kt)(g,{value:"changePubKeyByPrivateKey",label:"Call by the client with private key",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'pk := client.keyManager.PubKeyPoint()\ntxInfo := &types.ChangePubKeyReq{\n    L1Address: l1Address,\n    PubKeyX:   pk[0],\n    PubKeyY:   pk[1],\n}\ntxHash, err := client.ChangePubKey(txInfo, nil)\nassert.NoError(t, err)\nfmt.Printf("ChangePubKey success, tx_hash=%s \\n", txHash)\n'))),(0,a.kt)(g,{value:"changePubKeyBySeed",label:"Call by the client with seed",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'pk := client.keyManager.PubKeyPoint()\ntxInfo := &types.ChangePubKeyReq{\n    L1Address: l1Address,\n    PubKeyX:   pk[0],\n    PubKeyY:   pk[1],\n}\n// Generate the signature body for caller to calculate the signature\nsignBody, err := client.GenerateSignBody(txInfo, nil)\nassert.NoError(t, err)\nfmt.Printf("create ChangePubKey signature body:%s \\n", signBody)\n\n// Generate the signature with private key and outside the ChangePubKey function\nsignature, err := client.GenerateSignature(privateKey, txInfo)\nassert.NoError(t, err)\n\ntxHash, err := client.ChangePubKey(txInfo, nil, signature)\nassert.NoError(t, err)\nfmt.Printf("ChangePubKey success, tx_hash=%s \\n", txHash)\n')))),(0,a.kt)("h3",{id:"asset"},"Asset"),(0,a.kt)("h4",{id:"get-asset"},"Get Asset"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'asset, err := client.GetAssetBySymbol("BNB")\n')),(0,a.kt)("p",null,"Responses"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'// asset detail\n{\n    "id": 0,\n    "name": "BNB",\n    "decimals": 18,\n    "symbol": "BNB",\n    "address": "0x00",\n    "price": "0E+00",\n    "is_gas_asset": 1,\n    "icon": "https://raw.githubusercontent.com/binance-chain/tokens-info/master/tokens/bnb/bnb.png"\n}\n')),(0,a.kt)("h3",{id:"get-asset-by-id"},"Get Asset By Id"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"asset, err := client.GetAssetById(1)\n")),(0,a.kt)("h3",{id:"get-assets"},"Get Assets"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"assets, err := client.GetAssets(0, 10)\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "total": 4,\n  "assets": [\n    {\n      "id": 0,\n      "name": "BNB",\n      "decimals": 18,\n      "symbol": "BNB",\n      "address": "0x00",\n      "price": "0E+00",\n      "is_gas_asset": 1,\n      "icon": "https://static.devfdg.net/cloud-dapp/shared/icon/coin/bnb.svg"\n    },\n    {\n      "id": 1,\n      "name": "BUSD",\n      "decimals": 18,\n      "symbol": "BUSD",\n      "address": "0x9482fc890b76e1bd0927b77f02a1d31e817fC614",\n      "price": "0E+00",\n      "is_gas_asset": 1,\n      "icon": "https://static.devfdg.net/cloud-dapp/shared/icon/coin/busd.svg"\n    }\n  ]\n}\n\n')),(0,a.kt)("h4",{id:"transfer-asset"},"Transfer Asset"),(0,a.kt)(f,{mdxType:"Tabs"},(0,a.kt)(g,{value:"transferByPrivateKey",label:"Call by the client with private key",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'txInfo := types.TransferTxReq{\n    To:          "l1 address",\n    AssetId:     0,\n    AssetAmount: big.NewInt(1),\n}\n\nhash, err := client.Transfer(&txInfo, nil)\nassert.NoError(t, err)\nfmt.Println("transfer success, tx id=", hash)\n'))),(0,a.kt)(g,{value:"transferBySeed",label:"Call by the client with seed",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'txInfo := types.TransferTxReq{\n    To:          "l1 address",\n    AssetId:     0,\n    AssetAmount: big.NewInt(1),\n}\n// Generate the signature body for caller to calculate the signature\nsignBody, err := client.GenerateSignBody(&txInfo, nil)\nassert.NoError(t, err)\nfmt.Printf("create transfer signature body:%s \\n", signBody)\n\n// Generate the signature with private key and outside the transfer function\nsignature, err := client.GenerateSignature(privateKey, &txInfo)\nhash, err := client.Transfer(&txInfo, nil, signature)\nassert.NoError(t, err)\nfmt.Println("transfer success, tx id=", hash)\n')))),(0,a.kt)("h4",{id:"withdrawal-asset"},"Withdrawal Asset"),(0,a.kt)(f,{mdxType:"Tabs"},(0,a.kt)(g,{value:"withdrawByPrivateKey",label:"Call by the client with private key",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'randomAddress := "0x8b2C5A5744F42AA9269BaabDd05933a96D8EF911"\n\ntxReq := types.WithdrawTxReq{\n    AssetId:     0,\n    AssetAmount: big.NewInt(100),\n    ToAddress:   randomAddress,\n}\n\ntxId, err := client.Withdraw(&txReq, nil)\nassert.NoError(t, err)\nfmt.Printf("withdraw success, tx id: %s \\n", txId)\n'))),(0,a.kt)(g,{value:"withdrawBySeed",label:"Call by the client with seed",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'randomAddress := "0x8b2C5A5744F42AA9269BaabDd05933a96D8EF911"\n\ntxReq := types.WithdrawTxReq{\n    AssetId:     0,\n    AssetAmount: big.NewInt(100),\n    ToAddress:   randomAddress,\n}\n\n// Generate the signature body for caller to calculate the signature\nsignBody, err := client.GenerateSignBody(&txReq, nil)\nassert.NoError(t, err)\nfmt.Printf("create withdraw BEP signature body:%s \\n", signBody)\n\n// Generate the signature with private key and outside the Withdraw function\nsignature, err := client.GenerateSignature(privateKey, &txReq)\nassert.NoError(t, err)\n\ntxId, err := client.Withdraw(&txReq, nil, signature)\nassert.NoError(t, err)\nfmt.Printf("withdraw success, tx id: %s \\n", txId)\n')))),(0,a.kt)("h3",{id:"nft"},"NFT"),(0,a.kt)("h4",{id:"create-collection"},"Create Collection"),(0,a.kt)(f,{mdxType:"Tabs"},(0,a.kt)(g,{value:"createCollectionByPrivateKey",label:"Call by the client with private key",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'txInfo := types.CreateCollectionTxReq{\n    Name:         fmt.Sprintf("Nft Collection - my collection"),\n    Introduction: "Great Nft!",\n}\n\ntxId, err := client.CreateCollection(&txInfo, nil)\nassert.NoError(t, err)\nfmt.Printf("mint nft success, tx_hash: %s \\n", txId)\n'))),(0,a.kt)(g,{value:"createCollectionBySeed",label:"Call by the client with seed",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'txInfo := types.CreateCollectionTxReq{\n    Name:         fmt.Sprintf("Nft Collection - my collection"),\n    Introduction: "Great Nft!",\n}\n\n// Generate the signature body for caller to calculate the signature\nsignBody, err := client.GenerateSignBody(&txInfo, nil)\nassert.NoError(t, err)\nfmt.Printf("create collection signature body:%s \\n", signBody)\n\n// Generate the signature with private key and outside the Create Collection function\nsignature, err := client.GenerateSignature(privateKey, &txInfo)\nassert.NoError(t, err)\n\ntxId, err := client.CreateCollection(&txInfo, nil, signature)\nassert.NoError(t, err)\nfmt.Printf("mint nft success, tx_hash: %s \\n", txId)\n')))),(0,a.kt)("h4",{id:"get-max-collectionid"},"Get Max CollectionId"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"maxCollectionId, err := client.GetMaxCollectionId(1)\n")),(0,a.kt)("h4",{id:"mint-nft"},"Mint NFT"),(0,a.kt)(f,{mdxType:"Tabs"},(0,a.kt)(g,{value:"mintNftByPrivateKey",label:"Call by the client with private key",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'txInfo := types.MintNftTxReq{\n    To:                "l1 address",\n    NftCollectionId:   0,\n    NftContentType:    0,\n    RoyaltyRate:       0,\n    MetaData:          "any information",\n    MutableAttributes: "any mutable attributes",\n}\n\ntxId, err := client.MintNft(&txInfo, nil)\nassert.NoError(t, err)\nfmt.Printf("mint nft success, tx_hash: %s \\n", txId)\n'))),(0,a.kt)(g,{value:"mintNftBySeed",label:"Call by the client with seed",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'txInfo := types.MintNftTxReq{\n    To:                "l1 address",\n    NftCollectionId:   0,\n    NftContentType:    0,\n    RoyaltyRate:       0,\n    MetaData:          "any information",\n    MutableAttributes: "any mutable attributes",\n}\n\n// Generate the signature body for caller to calculate the signature\nsignBody, err := client.GenerateSignBody(&txInfo, nil)\nassert.NoError(t, err)\nfmt.Printf("mint nft signature body:%s \\n", signBody)\n\n// Generate the signature with private key and outside the MintNft function\nsignature, err := client.GenerateSignature(privateKey, &txInfo)\nassert.NoError(t, err)\n\ntxId, err := client.MintNft(&txInfo, nil, signature)\nassert.NoError(t, err)\nfmt.Printf("mint nft success, tx_hash: %s \\n", txId)\n')))),(0,a.kt)("h4",{id:"get-nft-next-nonce"},"Get Nft Next Nonce"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"nftIndex := 1\nnextNonce, err := client.GetNftNextNonce(nftIndex)\n")),(0,a.kt)("h4",{id:"get-nft-by-txhash"},"Get Nft By TxHash"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'nft, err := client.GetNftByTxHash("10e018bc926a1a879a71e628e80a698a9018a242227ed5dbbf1caaff1f506856")\n')),(0,a.kt)("h4",{id:"getnftbynftindex"},"GetNftByNftIndex"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"nft, err := client.GetNftByNftIndex(1)\n")),(0,a.kt)("h4",{id:"get-nfts-by-account-index"},"Get NFTs By Account Index"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"nfts, err := client.GetNftsByAccountIndex(4, 0, 10)\n")),(0,a.kt)("p",null,"Responses"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'// nfts\n{\n    "total": 2,\n    "nfts": [\n        {\n            "index": 2,\n            "creator_account_index": 4,\n            "creator_account_name": "walt.legend",\n            "owner_account_index": 4,\n            "owner_account_name": "walt.legend",\n            "content_hash": "000000000000000000000000000000000000000000000000000000000000000c",\n            "l1_address": "",\n            "l1_token_id": "",\n            "creator_treasury_rate": 0,\n            "collection_id": 0\n        },\n        {\n            "index": 1,\n            "creator_account_index": 4,\n            "creator_account_name": "walt.legend",\n            "owner_account_index": 4,\n            "owner_account_name": "walt.legend",\n            "content_hash": "000000000000000000000000000000000000000000000000000000000000000c",\n            "l1_address": "",\n            "l1_token_id": "",\n            "creator_treasury_rate": 0,\n            "collection_id": 0\n        }\n    ]\n}\n')),(0,a.kt)("h4",{id:"update-nft-by-index"},"Update Nft By Index"),(0,a.kt)(f,{mdxType:"Tabs"},(0,a.kt)(g,{value:"updateNftByPrivateKey",label:"Call by the client with private key",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'txInfo := types.UpdateNftReq{\n    NftIndex:          1,\n    MutableAttributes: "update information",\n}\n\nassetList, err := client.UpdateNftByIndex(&txInfo)\nif err != nil {\n    println(err.Error())\n    return\n}\n\nbz, _ := json.MarshalIndent(assetList, "", "  ")\nprintln(string(bz))\n'))),(0,a.kt)(g,{value:"updateNftBySeed",label:"Call by the client with seed",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'txInfo := types.UpdateNftReq{\n    NftIndex:          1,\n    MutableAttributes: "update information",\n}\n// Generate the signature body for caller to calculate the signature\nsignBody, err := client.GenerateSignBody(&txInfo, nil)\nassert.NoError(t, err)\nfmt.Printf("mint nft signature body:%s \\n", signBody)\n\n// Generate the signature with private key and outside the updateNft function\nsignature, err := client.GenerateSignature(privateKey, &txInfo)\nassert.NoError(t, err)\n\nassetList, err := client.UpdateNftByIndex(&txInfo, signature)\nif err != nil {\n    println(err.Error())\n    return\n}\n\nbz, _ := json.MarshalIndent(assetList, "", "  ")\nprintln(string(bz))\n')))),(0,a.kt)("h4",{id:"withdraw-nft"},"Withdraw NFT"),(0,a.kt)(f,{mdxType:"Tabs"},(0,a.kt)(g,{value:"withdrawNftByPrivateKey",label:"Call by the client with private key",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'randomAddress := "0x2fE6e6b5A084fEcd0A5cC109F7d5B5bbE9f0fE54"\n\ntxReq := types.WithdrawNftTxReq{\n    AccountIndex: 3,\n    NftIndex:     5,\n    ToAddress:    randomAddress,\n}\n\ntxId, err := client.WithdrawNft(&txReq, nil)\nassert.NoError(t, err)\nfmt.Printf("withdraw nft success, tx id: %s \\n", txId)\n'))),(0,a.kt)(g,{value:"withdrawNftBySeed",label:"Call by the client with seed",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'randomAddress := "0x2fE6e6b5A084fEcd0A5cC109F7d5B5bbE9f0fE54"\n\ntxReq := types.WithdrawNftTxReq{\n    AccountIndex: 3,\n    NftIndex:     5,\n    ToAddress:    randomAddress,\n}\n\n// Generate the signature body for caller to calculate the signature\nsignBody, err := client.GenerateSignBody(&txReq, nil)\nassert.NoError(t, err)\nfmt.Printf("create withdraw NFT signature body:%s \\n", signBody)\n\n// Generate the signature with private key and outside the WithdrawNft function\nsignature, err := client.GenerateSignature(privateKey, &txReq)\nassert.NoError(t, err)\n\ntxId, err := client.WithdrawNft(&txReq, nil, signature)\nassert.NoError(t, err)\nfmt.Printf("withdraw nft success, tx id: %s \\n", txId)\n')))),(0,a.kt)("h4",{id:"cancel-offer"},"Cancel Offer"),(0,a.kt)(f,{mdxType:"Tabs"},(0,a.kt)(g,{value:"cancelOfferByPrivateKey",label:"Call by the client with private key",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'account, err := client.GetAccountByL1Address(l1Addr)\nassert.NoError(t, err)\n\nofferId, err := client.GetMaxOfferId(account.Index)\nassert.NoError(t, err)\n\ntxInfo := types.CancelOfferTxReq{\n    OfferId: int64(offerId),\n}\n\ntxId, err := client.CancelOffer(&txInfo, nil)\nassert.NoError(t, err)\nfmt.Printf("cancel offer success, tx id: %s \\n", txId)\n'))),(0,a.kt)(g,{value:"cancelOfferBySeed",label:"Call by the client with seed",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'account, err := client.GetAccountByL1Address(l1Addr)\nassert.NoError(t, err)\n\nofferId, err := client.GetMaxOfferId(account.Index)\nassert.NoError(t, err)\n\ntxInfo := types.CancelOfferTxReq{\n    OfferId: int64(offerId),\n}\n\n// Generate the signature body for caller to calculate the signature\nsignBody, err := client.GenerateSignBody(&txInfo, nil)\nassert.NoError(t, err)\nfmt.Printf("create cancel offer signature body:%s \\n", signBody)\n\n// Generate the signature with private key and outside the Cancel Offer function\nsignature, err := client.GenerateSignature(privateKey, &txInfo)\nassert.NoError(t, err)\n\ntxId, err := client.CancelOffer(&txInfo, nil, signature)\nassert.NoError(t, err)\nfmt.Printf("cancel offer success, tx id: %s \\n", txId)\n')))),(0,a.kt)("h4",{id:"transfer-nft"},"Transfer Nft"),(0,a.kt)(f,{mdxType:"Tabs"},(0,a.kt)(g,{value:"transferNftByPrivateKey",label:"Call by the client with private key",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'nftIndex := int64(8)\ntxInfo := &types.TransferNftTxReq{\n    NftIndex: nftIndex,\n    To:       "l1 address",\n}\n\ntxId, err := client.TransferNft(txInfo, nil)\nassert.NoError(t, err)\nfmt.Printf("send transfer nft tx success, tx_id=%s \\n", txId)\n'))),(0,a.kt)(g,{value:"transferNftBySeed",label:"Call by the client with seed",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'nftIndex := int64(8)\ntxInfo := &types.TransferNftTxReq{\n    NftIndex: nftIndex,\n    To:       "l1 address",\n}\n\n// Generate the signature body for caller to calculate the signature\nsignBody, err := client.GenerateSignBody(txInfo, nil)\nassert.NoError(t, err)\nfmt.Printf("create transfer NFT signature body:%s \\n", signBody)\n\n// Generate the signature with private key and outside the transferNft function\nsignature, err := client.GenerateSignature(privateKey, txInfo)\nassert.NoError(t, err)\n\ntxId, err := client.TransferNft(txInfo, nil, signature)\nassert.NoError(t, err)\nfmt.Printf("send transfer nft tx success, tx_id=%s \\n", txId)\n')))),(0,a.kt)("h4",{id:"atomic-match"},"Atomic Match"),(0,a.kt)(f,{mdxType:"Tabs"},(0,a.kt)(g,{value:"atomicMathByPrivateKey",label:"Call by the client with private key",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'func CalculateSignature(signer accounts.Signer, tx *types.OfferTxInfo) ([]byte, error) {\n    convertedTx := txutils.ConvertOfferTxInfo(tx)\n    err := convertedTx.Validate()\n    if err != nil {\n        return nil, err\n    }\n    hFunc := mimc.NewMiMC()\n    msgHash, err := convertedTx.Hash(hFunc)\n    if err != nil {\n        return nil, err\n    }\n    hFunc.Reset()\n    signature, err := signer.Sign(msgHash, hFunc)\n    if err != nil {\n        return nil, err\n    }\n    return signature, nil\n}\n\nfunc PrepareAtomicMatchTxReq(client *client) (*types.AtomicMatchTxReq, error) {\n    sellPrivateKey := "0913b36e63e7beeb845d2b451d4c198dc5b8fccb1c82a1d2c0c01c951f275c81"\n    sellerSeed := "a976999fc597e1f182a2b6b5a791daa27361f969da4df22dbeb3753083ea45e76854c2272a48d2edccea1632de2facc6b5983b39263eb00f38003a8a754f42161b"\n    sellerAddress := "0xb7Db1bab8C31C0daa075fF2D645Ea6F0c9B0D01A"\n\n    buyPrivateKey := "355c102f0c8fb7efd0a2d66d70895e7cb0c4580eabc59073adb928d3e7315641"\n    buyerSeed := "d3774032687cf4875db03ef5073ddc9be6b5e464d00e7d308c3ba74e88ba802d1b2fef5641e3cc046ee3a8e205df3a7cd18545b3739c408d2ace4a6ed1dc01441c"\n    buyerAddress := "0xF792CC80193Ea942820C945F010051dE5CF6975A"\n\n    buyer, err := client.GetAccountByL1Address(buyerAddress)\n    if err != nil {\n        return nil, err\n    }\n\n    seller, err := client.GetAccountByL1Address(sellerAddress)\n    if err != nil {\n        return nil, err\n    }\n\n    buyerOfferId, err := client.GetMaxOfferId(buyer.Index)\n    if err != nil {\n        return nil, err\n    }\n\n    sellerOfferId, err := client.GetMaxOfferId(seller.Index)\n    if err != nil {\n        return nil, err\n    }\n\n    protocolRate, err := client.GetProtocolRate()\n    if err != nil {\n        return nil, err\n    }\n\n    nftIndex := int64(1)\n\n    nft, err := client.GetNftByNftIndex(nftIndex)\n    if err != nil {\n        return nil, err\n    }\n    listedAt := time.Now().UnixMilli()\n    expiredAt := time.Now().Add(time.Hour * 2).UnixMilli()\n    buyOffer := &types.OfferTxInfo{\n        Type:               types.BuyOfferType,\n        OfferId:            int64(buyerOfferId),\n        AccountIndex:       buyer.Index,\n        NftIndex:           nftIndex,\n        AssetId:            0,\n        AssetAmount:        big.NewInt(10000),\n        ListedAt:           listedAt,\n        ExpiredAt:          expiredAt,\n        RoyaltyRate:        nft.RoyaltyRate,\n        ChanelAccountIndex: 2,\n        ChanelRate:         200,\n        ProtocolRate:       protocolRate,\n        ProtocolAmount:     nil,\n        Sig:                nil,\n    }\n    buyOffer.ProtocolAmount = ffmath.Div(ffmath.Multiply(buyOffer.AssetAmount, big.NewInt(buyOffer.ProtocolRate)), big.NewInt(10000))\n\n    buyerKey, err := accounts.NewSeedKeyManager(buyerSeed)\n    if err != nil {\n        return nil, err\n    }\n\n    buyOfferSign, err := CalculateSignature(buyerKey, buyOffer)\n    if err != nil {\n        return nil, err\n    }\n    buyOffer.Sig = buyOfferSign\n\n    // Generate the signature body for caller to calculate the signature\n    buySignBody, err := client.GenerateSignBody(buyOffer, nil)\n\n    fmt.Printf("create atomic match signature body:%s \\n", buySignBody)\n\n    // Generate the signature with private key and outside the Atomic Match function\n    buySignature, err := client.GenerateSignature(buyPrivateKey, buyOffer)\n    buyOffer.L1Sig = buySignature\n\n    sellOffer := &types.OfferTxInfo{\n        Type:               types.SellOfferType,\n        OfferId:            int64(sellerOfferId),\n        AccountIndex:       seller.Index,\n        NftIndex:           nftIndex,\n        AssetId:            0,\n        AssetAmount:        big.NewInt(10000),\n        ListedAt:           listedAt,\n        ExpiredAt:          expiredAt,\n        ChanelAccountIndex: 3,\n        ChanelRate:         150,\n        Sig:                nil,\n    }\n\n    sellerKey, err := accounts.NewSeedKeyManager(sellerSeed)\n    if err != nil {\n        return nil, err\n    }\n\n    sellOfferSign, err := CalculateSignature(sellerKey, sellOffer)\n    if err != nil {\n        return nil, err\n    }\n    sellOffer.Sig = sellOfferSign\n\n    // Generate the signature body for caller to calculate the signature\n    sellSignBody, err := client.GenerateSignBody(sellOffer, nil)\n    fmt.Printf("create atomic match signature body:%s \\n", sellSignBody)\n    // Generate the signature with private key and outside the Atomic Match function\n    sellSignature, err := client.GenerateSignature(sellPrivateKey, sellOffer)\n    sellOffer.L1Sig = sellSignature\n\n    txInfo := &types.AtomicMatchTxReq{\n        BuyOffer:  buyOffer,\n        SellOffer: sellOffer,\n    }\n    return txInfo, nil\n}\n\ntxInfo, err := PrepareAtomicMatchTxReq(client)\nassert.NoError(t, err)\n\ntxId, err := client.AtomicMatch(txInfo, nil)\nassert.NoError(t, err)\nfmt.Printf("send atomic match tx success, tx_id=%s \\n", txId)\n'))),(0,a.kt)(g,{value:"atomicMathBySeed",label:"Call by the client with seed",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'func CalculateSignature(signer accounts.Signer, tx *types.OfferTxInfo) ([]byte, error) {\n    convertedTx := txutils.ConvertOfferTxInfo(tx)\n    err := convertedTx.Validate()\n    if err != nil {\n        return nil, err\n    }\n    hFunc := mimc.NewMiMC()\n    msgHash, err := convertedTx.Hash(hFunc)\n    if err != nil {\n        return nil, err\n    }\n    hFunc.Reset()\n    signature, err := signer.Sign(msgHash, hFunc)\n    if err != nil {\n        return nil, err\n    }\n    return signature, nil\n}\n\nfunc PrepareAtomicMatchTxReq(client *client) (*types.AtomicMatchTxReq, error) {\n    sellPrivateKey := "0913b36e63e7beeb845d2b451d4c198dc5b8fccb1c82a1d2c0c01c951f275c81"\n    sellerSeed := "a976999fc597e1f182a2b6b5a791daa27361f969da4df22dbeb3753083ea45e76854c2272a48d2edccea1632de2facc6b5983b39263eb00f38003a8a754f42161b"\n    sellerAddress := "0xb7Db1bab8C31C0daa075fF2D645Ea6F0c9B0D01A"\n\n    buyPrivateKey := "355c102f0c8fb7efd0a2d66d70895e7cb0c4580eabc59073adb928d3e7315641"\n    buyerSeed := "d3774032687cf4875db03ef5073ddc9be6b5e464d00e7d308c3ba74e88ba802d1b2fef5641e3cc046ee3a8e205df3a7cd18545b3739c408d2ace4a6ed1dc01441c"\n    buyerAddress := "0xF792CC80193Ea942820C945F010051dE5CF6975A"\n\n    buyer, err := client.GetAccountByL1Address(buyerAddress)\n    if err != nil {\n        return nil, err\n    }\n\n    seller, err := client.GetAccountByL1Address(sellerAddress)\n    if err != nil {\n        return nil, err\n    }\n\n    buyerOfferId, err := client.GetMaxOfferId(buyer.Index)\n    if err != nil {\n        return nil, err\n    }\n\n    sellerOfferId, err := client.GetMaxOfferId(seller.Index)\n    if err != nil {\n        return nil, err\n    }\n\n    protocolRate, err := client.GetProtocolRate()\n    if err != nil {\n        return nil, err\n    }\n\n    nftIndex := int64(1)\n\n    nft, err := client.GetNftByNftIndex(nftIndex)\n    if err != nil {\n        return nil, err\n    }\n    listedAt := time.Now().UnixMilli()\n    expiredAt := time.Now().Add(time.Hour * 2).UnixMilli()\n    buyOffer := &types.OfferTxInfo{\n        Type:               types.BuyOfferType,\n        OfferId:            int64(buyerOfferId),\n        AccountIndex:       buyer.Index,\n        NftIndex:           nftIndex,\n        AssetId:            0,\n        AssetAmount:        big.NewInt(10000),\n        ListedAt:           listedAt,\n        ExpiredAt:          expiredAt,\n        RoyaltyRate:        nft.RoyaltyRate,\n        ChanelAccountIndex: 2,\n        ChanelRate:         200,\n        ProtocolRate:       protocolRate,\n        ProtocolAmount:     nil,\n        Sig:                nil,\n    }\n    buyOffer.ProtocolAmount = ffmath.Div(ffmath.Multiply(buyOffer.AssetAmount, big.NewInt(buyOffer.ProtocolRate)), big.NewInt(10000))\n\n    buyerKey, err := accounts.NewSeedKeyManager(buyerSeed)\n    if err != nil {\n        return nil, err\n    }\n\n    buyOfferSign, err := CalculateSignature(buyerKey, buyOffer)\n    if err != nil {\n        return nil, err\n    }\n    buyOffer.Sig = buyOfferSign\n\n    // Generate the signature body for caller to calculate the signature\n    buySignBody, err := client.GenerateSignBody(buyOffer, nil)\n\n    fmt.Printf("create atomic match signature body:%s \\n", buySignBody)\n\n    // Generate the signature with private key and outside the Atomic Match function\n    buySignature, err := client.GenerateSignature(buyPrivateKey, buyOffer)\n    buyOffer.L1Sig = buySignature\n\n    sellOffer := &types.OfferTxInfo{\n        Type:               types.SellOfferType,\n        OfferId:            int64(sellerOfferId),\n        AccountIndex:       seller.Index,\n        NftIndex:           nftIndex,\n        AssetId:            0,\n        AssetAmount:        big.NewInt(10000),\n        ListedAt:           listedAt,\n        ExpiredAt:          expiredAt,\n        ChanelAccountIndex: 3,\n        ChanelRate:         150,\n        Sig:                nil,\n    }\n\n    sellerKey, err := accounts.NewSeedKeyManager(sellerSeed)\n    if err != nil {\n        return nil, err\n    }\n\n    sellOfferSign, err := CalculateSignature(sellerKey, sellOffer)\n    if err != nil {\n        return nil, err\n    }\n    sellOffer.Sig = sellOfferSign\n\n    // Generate the signature body for caller to calculate the signature\n    sellSignBody, err := client.GenerateSignBody(sellOffer, nil)\n    fmt.Printf("create atomic match signature body:%s \\n", sellSignBody)\n    // Generate the signature with private key and outside the Atomic Match function\n    sellSignature, err := client.GenerateSignature(sellPrivateKey, sellOffer)\n    sellOffer.L1Sig = sellSignature\n\n    txInfo := &types.AtomicMatchTxReq{\n        BuyOffer:  buyOffer,\n        SellOffer: sellOffer,\n    }\n    return txInfo, nil\n}\n\ntxInfo, err := PrepareAtomicMatchTxReq(client)\nassert.NoError(t, err)\n\n// Generate the signature with private key\nsignature, err := client.GenerateSignature(privateKey, txInfo)\ntxId, err := client.AtomicMatch(txInfo, nil, signature)\nassert.NoError(t, err)\nfmt.Printf("send atomic match tx success, tx_id=%s \\n", txId)\n')))),(0,a.kt)("h2",{id:"zkbnb-l1-client"},"zkBNB L1 Client"),(0,a.kt)("p",null,"The zkBNBL1Client is used to interact with zkBNB proxy contract in l1."),(0,a.kt)("h3",{id:"interface"},"Interface"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"    type ZkBNBL1Client interface {\n        // SetPrivateKey will set the private key of the l1 account\n        SetPrivateKey(pk string) error\n        \n        // DepositBNB will deposit specific amount bnb to l2\n        DepositBNB(accountName string, amount *big.Int) (common.Hash, error)\n    \n        // DepositBEP20 will deposit specific amount of bep20 token to l2\n        DepositBEP20(token common.Address, accountName string, amount *big.Int) (common.Hash, error)\n    \n        // DepositNft will deposit specific nft to l2\n        DepositNft(nftL1Address common.Address, accountName string, nftL1TokenId *big.Int) (common.Hash, error)\n    \n        // RegisterZNS will register account in l2\n        RegisterZNS(name string, owner common.Address, pubKeyX [32]byte, pubKeyY [32]byte) (common.Hash, error)\n        \n        // RequestFullExit will request full exit from l2\n        RequestFullExit(accountName string, asset common.Address) (common.Hash, error)\n    \n        // RequestFullExitNft will request full nft exit from l2\n        RequestFullExitNft(accountName string, nftIndex uint32) (common.Hash, error)\n    }\n")),(0,a.kt)("h3",{id:"init"},"Init"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'    client := NewZkBNBL1Client("l1 provider", "zkbnb proxy contract address")\n')),(0,a.kt)("h3",{id:"send-tx"},"Send tx"),(0,a.kt)("p",null,"Before you send tx, you need to set a private key to sign the tx:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'    client.SetPrivateKey("private key")\n')),(0,a.kt)("p",null,"Then you can send txs."),(0,a.kt)("h3",{id:"register-zns"},"Register ZNS"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'    var l2KeyManager, _ = accounts.NewSeedKeyManager("Random Seed")\n    var l2Name = "xxx.legend"\n    pk := l2KeyManager.PubKeyPoint()\n    txHash, err := client.RegisterZNS("test1", common.HexToAddress(l1Address), big.NewInt(1e17), pk[0], pk[1])\n')),(0,a.kt)("h3",{id:"deposit-bnb"},"Deposit BNB"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'    txHash, err := client.DepositBNB("test1", big.NewInt(1e18))\n')),(0,a.kt)("h3",{id:"deposit-bep20"},"Deposit BEP20"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'    txHash, err := client.DepositBEP20(common.HexToAddress("token address"), "account name", big.NewInt(1000000))\n')),(0,a.kt)("h3",{id:"full-exit-token"},"Full Exit Token"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'    txHash, err := client.RequestFullExit("account name", common.HexToAddress("token address"))\n')),(0,a.kt)("h3",{id:"full-exit-token-1"},"Full Exit Token"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'    txHash, err := client.RequestFullExit("account name", common.HexToAddress("token address"))\n')),(0,a.kt)("h3",{id:"deposit-nft"},"Deposit NFT"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'    txHash, err := client.DepositNft("nft address", "account name", big.NewInt(1000000))\n')),(0,a.kt)("h3",{id:"full-exit-nft"},"Full Exit NFT"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'    txHash, err := client.RequestFullExitNft("account name", big.NewInt(1000000))\n')))}y.isMDXComponent=!0}}]);