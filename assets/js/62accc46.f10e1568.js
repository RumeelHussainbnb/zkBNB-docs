"use strict";(self.webpackChunkzkbnb_docs=self.webpackChunkzkbnb_docs||[]).push([[2246],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>k});var o=r(67294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,o)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,o,n=function(e,t){if(null==e)return{};var r,o,n={},a=Object.keys(e);for(o=0;o<a.length;o++)r=a[o],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)r=a[o],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=o.createContext({}),c=function(e){var t=o.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var r=e.components,n=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(r),d=n,k=u["".concat(l,".").concat(d)]||u[d]||h[d]||a;return r?o.createElement(k,i(i({ref:t},p),{},{components:r})):o.createElement(k,i({ref:t},p))}));function k(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var a=r.length,i=new Array(a);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:n,i[1]=s;for(var c=2;c<a;c++)i[c]=r[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,r)}d.displayName="MDXCreateElement"},76475:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var o=r(87462),n=(r(67294),r(3905));const a={title:"What powers zkBNB"},i="What powers zkBNB",s={unversionedId:"guide/introduction/tech-zkBNB",id:"guide/introduction/tech-zkBNB",title:"What powers zkBNB",description:"What is layer 2?",source:"@site/docs/guide/introduction/tech-zkBNB.md",sourceDirName:"guide/introduction",slug:"/guide/introduction/tech-zkBNB",permalink:"/zkBNB-docs/docs/guide/introduction/tech-zkBNB",draft:!1,editUrl:"https://github.com/RumeelHussainbnb/zkBNB-docs/docs/guide/introduction/tech-zkBNB.md",tags:[],version:"current",frontMatter:{title:"What powers zkBNB"},sidebar:"guideSidebar",previous:{title:"What is zkBNB?",permalink:"/zkBNB-docs/docs/guide/introduction/overview"},next:{title:"Fee Structure",permalink:"/zkBNB-docs/docs/guide/introduction/fee-structure"}},l={},c=[{value:"What is layer 2?",id:"what-is-layer-2",level:2},{value:"How do ZK Rollups work?",id:"how-do-zk-rollups-work",level:2},{value:"Key Tech",id:"key-tech",level:2},{value:"Sparse Merkle Tree KV Store",id:"sparse-merkle-tree-kv-store",level:3},{value:"Circuit Model",id:"circuit-model",level:3},{value:"How does Groth16 zk-SNARK works?",id:"how-does-groth16-zk-snark-works",level:4}],p={toc:c};function u(e){let{components:t,...r}=e;return(0,n.kt)("wrapper",(0,o.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"what-powers-zkbnb"},"What powers zkBNB"),(0,n.kt)("h2",{id:"what-is-layer-2"},"What is layer 2?"),(0,n.kt)("p",null,'"Layer 2" is a term used to describe mechanisms that process batches of transactions independently of layer 1 and only periodically reports them to the main chain. This decreases the total number of transactions that have to be validated on layer 1. Layer 2s are also known as "execution layers" or "rollups".'),(0,n.kt)("p",null,"zkBNB is built using zk rollup technology is supposed to work as a Layer-2 for BNB Smart Chain (BSC)."),(0,n.kt)("h2",{id:"how-do-zk-rollups-work"},"How do ZK Rollups work?"),(0,n.kt)("p",null,"ZK rollups consist of two main components:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Off-chain batching mechanism:")," generates a cryptographic proof from a batch of transactions in a highly compressed form together with the previous state root and the new state root.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"On-chain contract:")," "),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Stores the current state root of the rollup. "),(0,n.kt)("li",{parentName:"ul"},"Verifies that the previous state root in the batch matches the current state root. If so, it switches the state root to the new state root.")))),(0,n.kt)("h2",{id:"key-tech"},"Key Tech"),(0,n.kt)("p",null,"The key tech stack that powers the zkBNB are the BAS-SMT and zkBNB-crypto."),(0,n.kt)("h3",{id:"sparse-merkle-tree-kv-store"},"Sparse Merkle Tree KV Store"),(0,n.kt)("p",null,"Unlike most rollup solution to put the state tree in memory, ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/bnb-chain/zkbnb-smt/"},"BAS-SMT")," is a versioned, snapshottable (immutable) sparse tree for persistent data. BAS-SMT is the key factor for the massive adoption of zkBNB."),(0,n.kt)("h3",{id:"circuit-model"},"Circuit Model"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/bnb-chain/zkbnb-crypto"},"zkBNB Crypto")," is the library that describe the proving circuit. Once the ZK-rollup node has enough transactions, it aggregates them into a batch and compiles inputs for the proving circuit to compile into a succinct zk-proof."),(0,n.kt)("p",null,"zkbnb-crypto is the crypto library for zkBNB Protocol. It implements rollup block circuit and supports exporting groth16/plonk proving key, verifying key and solidity verifier contract. In order to be able to generate a proof from the prover side for the verifier to verify it, we use the argument system (zk-SNARK) for our arithmetic circuit."),(0,n.kt)("p",null,"There are 2 types of argument systems (interactive and non-interactive) and in zkbnb-crypto non-interactive argument system is used - ",(0,n.kt)("strong",{parentName:"p"},"Groth16"),"."),(0,n.kt)("h4",{id:"how-does-groth16-zk-snark-works"},"How does Groth16 zk-SNARK works?"),(0,n.kt)("p",null,"In short, here is how Groth16 zk-SNARK works:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"There is a preprocessing Setup procedure which generates public parameters Sp (PK) and Sv (VK) for a given Circuit C."),(0,n.kt)("li",{parentName:"ol"},"Prover uses PK, public variable X and private witness W to generate proof."),(0,n.kt)("li",{parentName:"ol"},"Verifier uses VK, public variable X and generated proof to accept or reject it.")))}u.isMDXComponent=!0}}]);